# 그래프와 BFS

## 그래프 Graph

* 자료구조의 일종
* 정점 (Node, Vertex)
* 간선 (Edge) : 정점간의 관계를 나타냄
* G = (V, E)

## 

## 경로 Path

* 정점 A에서 B로 가는 경로
* A -> C -> D -> E -> B
* A -> B : 최단경로(가중치 있을 땐 가중치 합이 가장 작은거)
* A -> C -> B
* A -> C -> E -> B



## 사이클

* 시작점과 도착점이 같은 경로



## 단순 경로와 단순 사이클 Simple Path and Simple Cycle

* 경로/사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로/사이클
* 특별한 말이 없으면, 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클을 말한다.



## 방향 있는 그래프 Directed Graph

* A -> C 와 같이 간선에 방향이 있다.



## 방향 없는 그래프 Undirected Graph

* A-C는 A->C와 C->A를 나타낸다
* 양방향 그래프(Bidirection Graph)



## 간선 여러개 Multiple Edge

* 두 정점 사이에 간선이 여러 개일 수도 있다.
* A-B는 연결하는 간선이 2개
* 두 간선은 서로 다른 간선



## 루프 Loop

* 간선의 양 끝 점이 같은 경우
* A -> A



## 가중치 Weight

* 간선에 가중치가 있는 경우
* A에서 B로 이동하는 거리, 이동하는데 필요한 시간, 이동하는데 필요한 비용 등등
* 가중치가 없는 경우에는 1이라고 생각하면 됨



## 차수 Degree

* 정점과 연결되어 있는 간선의 개수
* 방향 그래프의 경우 In-degree, Out-degree로 나누어서 차수를 계산



# 그래프의 표현 Representation of Graph

간선에 방향이 없는 방향이 없는 그래프. 정점이 6개, 간선이 8개

정점: {1, 2, 3, 4, 5, 6}

간선: {(1, 2), (1, 5), (2, 5), (2, 3), (3, 4), (2, 4), (4, 5), (4, 6)}



### 인접 행렬 Adjacency-matrix

* 정점의 개수를 V이라고 했을 때
* V X V 크기의 이차원 배열을 이용
* $A[i]A[j] = 1$ (i -> j 간선이 있을 때), 0 (없을 때)



### 인접 리스트 Adjacency-list

* 리스트를 이용해서 구현
* A[i] = i와 연결된 정점을 리스트로 포함하고 있음
* 리스트의 크기는 동적으로 변경할 수 있어야 한다
* 즉, 링크드 리스트나 길이를 동적으로 변경할 수 있는 배열을 사용. 파이썬은 List

```
A[1] (2,2) (5,7)
A[2] (1,2) (3,2) (4,3) (5,1)
A[3] (2,2) (4,1)
A[4] (3,1) (5,7) (2,3) (6,7)
A[5] (1,7) (2,1) (4,7)
A[6] (4,7)
```



## 공간 복잡도 Space Complexity

* 인접 행렬: O(V^2)

  * 장점 2가지

    1. 인접 행렬은 임의의 두 정점 u,v가 주어졌을 때 u->v 존재하는지 O(1) $A[u][v]$ 가 1인지 보면 됨

       인접 리스트는 A[u] 간선 모두 살펴봐야해서 u의 차수만큼 걸림

    2. 임의의 두 정점 u,v가 주어졌을 때 반대방향 정점 찾는 것도 O(1)

       인접 리스트는 v의 차수만큼 걸림

* 인접 리스트: O(E)

예외 : 완전 그래프. 그래프의 모든 정점 사이에 간선이 존재. $E=V(V-1)/2$ 인접 행렬이 더 좋음



## 간선 리스트 Edge-list

* 배열을 이용해서 구현
* 간선을 모두 저장
* E라는 배열에 간선을 모두 저장
* 동적 할당 없이 인접 리스트와 비슷한 효과



# 그래프의 탐색 (DFS, BFS)



### 그래프의 탐색 

목적 : 시작점 X 시작해서 모든 정점을 1번씩

* DFS: 깊이 우선 탐색
* BFS: 너비 우선 탐색



### 깊이 우선 탐색 Depth First Search

* 스택을 이용해서 갈 수 있는 만큼 최대한 많이 가고
* 갈 수 없으면 이전 정점으로 돌아간다.

정점을 한번씩 방문했는지 확인하기 위해 check 배열 필요

스택에서 pop하면서 비어있게되면 탐색 종료



재귀 호출 구현

```c++
// 인접 행렬을 이용한 구현
void dfs(int x) {  // dfs(x) x에 방문했다를 의미
    check[x] = true;
    printf("%d ",x);
    for (int i=1; i<=n; i++) {
        if (a[x][i] == 1 && check[i] == false) {
            dfs(i);
        }
    }
}

// 인접 리스트를 이용한 구현
void dfs(int x) {
    check[x] = true;
    printf("%d ",x);
    for (int i=0; i<a[x].size(); i++) {
        int y = a[x][i];
        if (check[y] == false) {
            dfs(y);
        }
    }
}
```







