# L7

1. # 재귀함수의 이론 (basic recursive function)

### 재귀함수의 정의

재귀함수☆ 컴퓨터공학 고유의 것

함수

* 값을 입력받아 특정 연산을 수행하여 결과를 반환

```c
#include <stdio.h>

int getSum(int first, int second) {
  return first+second;
}

int main() {
  int a, b;
  int result;
  
  scanf("%d %d", &a, &b);
  
  result = getSum(a, b);  
  
  printf("%d\n", result);
  
  return 0;
}
```

함수 요약

* 함수의 기본 형태

  반환 형, 함수 이름, 인자, 값 반환

* 스코프는 함수간 작업의 완벽한 분담을 위해 존재한다

* 의미단위의 프로그래밍을 해야한다

  문제 해결을 위해 어떤 일을 하는 함수가 필요한지를 설계

재귀함수

* 자기 자신을 부르는 함수

  ```c
  int main() {
      main();
      
      return 0;
  }
  ```

  

### 재귀함수가 의미있는 예제

```c
#include <stdio.h>

// getFactorial(n) : n! 을 반환하는 함수
int getFactorial(int n) {
  if(n == 0)
    return 1;
  else
    return n * getFactorial(n-1);
}

int main() {
  int n;
  scanf("%d", &n);
  printf("%d\n", getFactorial(n));  // getFactorial(n)이 반환하는 숫자를 출력 
}

/*
main()  n 4  // getFactorial(4) 기다림
-------------------------------------------------------------------------
getFactorial(4)  n 4    // getFactorial(3)을 기다리고 있음. 값을 알아야해서
-------------------------------------------------------------------------
getFactorial(3)  n 3    // scope이 다름. 다른 변수.
-------------------------------------------------------------------------
getFactorial(2)  n 2
-------------------------------------------------------------------------
getFactorial(1)  n 1
-------------------------------------------------------------------------
getFactorial(0)  n 0    // 나를 부른 애(getFactorial(1)에게 1 return
*/
```



### 팩토리얼의 구현

```c
#include <stdio.h>

int getFactorial(int n) {
  // getFactorial(n) = n! 을 반환하는 함수
  
  if(n == 0)
    return 1;
  else
    return n * getFactorial(n-1);
}

int main() {
  int n;
  
  scanf("%d", &n);
  
  printf("%d\n",getFactorial(n));
  return 0;
}
```



### 값의 계산을 위한 두 가지 방법

재귀함수를 이해하기 위한 질문

* 재귀함수의 의미는 무엇인가? 도대체 이걸 왜 쓰나?
* 재귀함수를 만들기 위해서는 어떤 절차를 따라야 하나?

재귀함수의 의미

* 귀납적 계산 방법 (귀납적 문제해결 방법)

두 가지 계산 방법

* 순차적 계산법

  A를 계산한다.

  A를 이용해서 B를 계산한다.

  B를 이용해서 C를 계산한다.

  C를 이용해서 D를 계산함으로써 원하는 결과를 얻는다.

  [EX]

  Q. 4의 약수의 개수를 구하라

  - C에 0을 넣는다
  - 4가 1로 나누어 떨어지면 C에 1을 더한다
  - 4가 2로 나누어 떨어지면 C에 1을 더한다
  - 4가 3로 나누어 떨어지면 C에 1을 더한다
  - 4가 4로 나누어 떨어지면 C에 1을 더한다

* 귀납적 계산법

  구하려고 하는 값을 f(x)함수 라고 하자.

  f(x)를 구하기 위하여 또 다시 f(x)를 활용한다.

  f(n) = n x f(n-1) ,  f(0) = 1(0!=1)

  n! = 1 x 2 x ... x n  <-  정의X. 순차적

  n! = n x (n-1)! ,  0!=1  <-  팩토리얼 정의. 팩토리얼을 구하기 위해서 팩토리얼을 씀. 귀납적. 식을 정의. 멈추라는 신호 정의

  f(5) = 5 x f(4) = 5 x 4 x f(3) = 5 x 4 x 3 x f(2) = 5 x 4 x 3 x 2 x f(1) = 5 x 4 x 3 x 2 x 1 x f(0) = 5 x 4 x 3 x 2 x 1 x 1

  

### 귀납적 계산법 내의 가정 관계

두 가지 계산 방법

* 귀납적 계산법

  구하려고 하는 값을 f(x)라고 하자.

  f(x)를 구하기 위하여 또 다시 f(x)를 활용한다.

  #### "나"를 계산하기 위해 또 다시 "나"를 활용한다

귀납적 계산법의 깊은 이해

n의 m승을 귀납적으로 계산하여라

n의 m승 = n의 m-1승 x n ,  n의0승 = 1(정의=약속)

왜 귀납적 계산법이 제대로 된 값을 반환하는가?

1) 수많은 가정을 하다가

2) 맨 끝에는 정확한 값(정의)이 있기 때문이다

5의 4승 = 5의 3승 x 5

5의 3승 = 5의 2승 x 5

5의 2승 = 5의 1승 x 5

5의 1승 = 5의 0승 x 5

5의 0승 = 1(맞는 값)

(n을 m번 곱하는 것) = (n을 m-1번 곱하는 것) x n

1. 식을 정의
2. 멈추라는 신호(조건) 정의



### 재귀함수와 재귀적 계산법

재귀함수가 의미있는 예제

```c
#include <stdio.h>

// getFactorial(n) : n! 을 반환하는 함수
// 수학적 귀납법(증명을 하는 방법)
int getFactorial(int n) {
  if(n==0)
    return 1;
  else
    return n * getFactorial(n-1);
}
// getFactorial(4) = 4 x getFactorial(3)  
//    ↑ getFactorial(3)이 3!을 제대로 반환한다는 가정이 숨어있음
// getFactorial(3) = 3 x getFactorial(2)
// getFactorial(2) = 2 x getFactorial(1)
// getFactorial(1) = 1 x getFactorial(0)
// getFactorial(0) = 1
// -----------------------------------------------------------
// main()  n  4
int main() {
  int n;
  scanf("%d", &n);
  printf("%d\n", getFactorial(n));
}
```



### 수학적 귀납법

getFactorial함수가 왜 n!을 제대로 반환하는지 수학적으로 엄밀하게 증명

수학적 귀납법

* 명제 P(n)이 모든 자연수 n에 대하여 성립함을 보이자

* 증명 순서

  P(1)이 참임을 보인다.

  P(k)가 성립한다고 가정한 후, P(k+1)이 성립함을 보인다.

  따라서 모든 자연수 n에 대하여 P(n)이 성립한다.

수학적 귀납법의 예

* 명제 : 모든 자연수 n에 대하여 다음이 성립함을 보여라

* 명제 : 참/거짓을 판단할 수 있는 문장

  1 + 2 + ... + n = n(n+1) / 2  <-  P(n)

  ```
  P(1)이 성립함을 보인다.
  1 = 1
  
  P(k)가 성립한다고 가정한 후, P(k+1)이 성립함을 보인다.
  1 + 2 + ... + k = k(k+1)/2이 될 때
  1 + 2 + ... + k + (k+1) = (k+1)(k+2)/2 되는가?
  =>
  1 + 2 + ... + k = k(k+1)/2 양변에 (k+1) 더한다
  1 + 2 + ... + k + (k+1) = k(k+1)/2 + (k+1)
  1 + 2 + ... + k + (k+1) = {k제곱 + k + (2k + 2)} / 2
                          = (k제곱 + 3k + 2) / 2  <- 인수분해
                          = (k+1)(k+2) / 2
  ```

  

### 재귀함수의 정확성 증명

```c
#include <stdio.h>

// getFactorial(n) : n! 을 반환하는 함수
int getFactorial(int n) {  
  // getFactorial(n)코드 자체가 증명임
  // 재귀함수가 하는 일 : 귀납적으로 계산하는 방법
  if(n==0)
    return 1;
  else
    return n * getFactorial(n-1);
}

int main() {
  int n;
  scanf("%d", &n);
  printf("%d\n", getFactorial(n));
}
```

```
getFactorial(0) = 1
getFactorial(k) = k! -> getFactorial(k+1) = (k+1)!
getFactorial(k-1) = (k-1)! -> getFactorial(k) = k!
```



### 재귀함수의 디자인 절차

```c
#include <stdio.h>

// getFactorial(n) : n! 을 반환하는 함수
int getFactorial(int n) {  
  // getFactorial(n)코드 자체가 증명임
  // 재귀함수가 하는 일 : 귀납적으로 계산하는 방법
  if(n==0)
    return 1;
  else
    return n * getFactorial(n-1);  // getFactorial(n-1) 제대로 동작한다고 가정
}

int main() {
  int n;
  scanf("%d", &n);
  printf("%d\n", getFactorial(n));
}
```

* 재귀함수 디자인을 위한 3가지 절차 ☆☆☆

  1) 함수의 역할을 말로 정확하게 정의한다.

  2) 기저조건(Base condition. 제일 단순한 경우)에서 함수가 제대로 동작함을 보인다.

  3) 함수가 (작은 input에 대하여) 제대로 동작한다고 가정하고 함수를 완성한다.

# 2. 재귀함수의 구현

### 예제 1 : 거듭제곱 구하기 1



### 예제 1 : 거듭제곱 구하기 2



### 예제 2 : N to M 1



### 예제 2 : N to M 2



### 예제 3 : 각 자릿수의 합 1



### 예제 3 : 각 자릿수의 합 2



### 예제 4 : 이진수 출력하기 1



### 예제 4 : 이진수 출력하기 2



### 예제 5 : 팰린드롬인지 판별하기 1



### 예제 5 : 팰린드롬인지 판별하기 2



팩토리얼

```c

```

binary

```c

```

mountain

```c

```

