# L9

1. # 고급 정렬 (Advanced Sort)

### 정렬의 복습

Adv. Sorting Algorithm

(Recap.) 정렬

* 특정 기준을 적용하여 나열함

  오름차순 정렬: 갈수록 커지는 것

  내림차순 정렬: 갈수록 작아지는 것

* 정렬의 종류

  1) 선택정렬

  * 최솟값을 앞으로 이동시킴
  * 시간복잡도: 최솟값을 한 번 찾는데 O(n) 걸림. 최솟값을  n번 찾아야 함. O(n^2)

  2) 삽입정렬

  * 원소를 차례대로 정렬된 배열에 삽입시킴
  * 시간복잡도: 원소 하나를 삽입하는데 O(n) 걸림. 삽입을 n번 해야함. O(n^2)

  3) 버블정렬

  * 인접한 원소를 비교하여 큰 수를 뒤로 보냄
  * 시간복잡도: 맨 뒤의 숫자를 확정하는데 O(n) 걸림. n개의 숫자를 확정해야 함. O(n^2)



### 더 빠른 정렬의 종류

더 빠르게 정렬할 수는 없을까?

* O(n log n)만에 정렬할 수 있다

  합병정렬

  퀵정렬

  힙정렬(지금 배우지는 않음)



### 로그의 개념과 그 효율성

로그의 정의

* 지수함수의 역함수

  log x(밑)에 y = z <=> x^z =y <=> x를 몇 번 곱해야 y가 되는가?

밑이 2인 log

* 컴퓨터 공학에서 log를 쓰는 경우 그 밑이 2이므로, 보통 밑을 생략한다.

  logx = 2를 몇 번 곱해야 x가 되는가

  log32 = 5

  log64 = 6

  log50 -> 2^? = 50    2^5(=32) <= 50 <= 2^6(=64)

  ?에 들어가는 숫자는 5보다는 크고 6보다 작음. 5.xxxx

  log50 = 5.6439

  log1024 = 10

  log1048576 = 20

  log1099511627776 = 40

  log2^100 = 100

  log10^100 = 332.1928

* O(log n) vs O(n)

  n이 커질수록 비교가 안되게 log n이 작은 수

  lon n이 시간복잡도에 들어감 = 굉장히 빠른 알고리즘

log 시간복잡도의 중요성

* log n은 숫자가 크지 않기 때문에 속도에 영향이 적음
* 따라서 log n이 들어간 시간복잡도는 매우 빠른 편에 속한다고 할 수 있다.



2. # 합병 정렬 (Merge Sort)

### 합병정렬의 개념과 예제

더 빠르게 정렬할 수는 없을까?

* O(n log n) 만에 정렬할 수 있다

  ☆합병정렬 - 재귀호출, 혹은 재귀적 구조를 이용한 정렬

  ☆퀵정렬 - 재귀호출, 혹은 재귀적 구조를 이용한 정렬

  ☆힙정렬(지금 배우지는 않음)

합병정렬

* 배열을 절반으로 나누어 각각을 정렬한 후, 합친다.

  ```
  4  8  11  14  23    2  3  4  5  9
  v                   v
  왼쪽 맨 끝. 이 중 최솟값이 있음. 이 두개 비교하면 맨 앞 숫자 구할 수 있음.
  
  2
  
  그 다음은 4 아니면 3
  
  2 3 
  
  그 다음은 4
  
  2 3 4 ...
  
  그래서 각각은 어떻게 정렬?
  절반을 정렬할 때 또 합병정렬을 이용. 재귀적.
  합병정렬하기 위해 또 합병정렬.
  
  왼쪽합병정렬하려면 또 절반으로 나누고, 그 각각을 합병정렬..
  
  원소가 하나밖에 없으면 정렬이 된 것.
  ```

  

### 합병정렬의 시간복잡도

합병정렬의 시간복잡도 - 재귀적으로 구해야함. 알고리즘이 재귀적이니까

* T(n) = n개의 숫자를 합병정렬 할 때의 시간복잡도

  T(n) = O(n log n)

  1. 왼쪽 합병정렬 = T(n/2)
  2. 오른쪽 합병정렬 = T(n/2)
  3. 합친다 = O(n)

  2 3 4 9  |  1 4 5 7  

  1 2 3 4 4 한번 비교하면 숫자 하나가 나옴. n개 나와야하니까 n번 비교해야함

* T(n) = 2 x T(n/2) + O(n) = 점화식 = 4T(n/4) + 2O(n) = 8T(n/8) + 3O(n)

  =....= 2^(k+1)T(n/2^(K+1))+(k+1)O(n) = n x T(1) + log n x O(n) 

  T(n) = 2^(1+log n)T(1) + O(n log n) = n x O(1) + O(n log n) = O(n) + O(n log n) = O(n log n)

  K+1 = log n

* T(n/2) = 2(2*T(n/4)+O(n/2)) 

```
14  4  8  23  11  5  3  2  4  9  O(n)<- 합치는데 걸리는 시간
14  4  8  23  11  |  5  3  2  4  9  O(n/2) + O(n/2) = O(n)
14  4  8  |  23  11  |  5  3  2  |  4  9
14  |  4  |  8  |  23  |  11  |  5  |  3  |  2  |  4  |  9 
각 층은 O(n) 걸림. 층수(몇 번이나 절반으로 나눌 수 있는가?) 절반을 몇번으로 쪼개야 하나가 나오는가?
2를 몇번 곱해야 n이 되는가? 2^k=n / k=log n
O(n log n)
```



### 합병정렬의 재귀함수 디자인



### 합병정렬의 구현 1



### 합병 정렬의 구현2



합병정렬 구현하기

```c

```

# 3. 퀵 정렬 (Quick Sort)

### 퀵정렬의 개념과 예제



### 퀵정렬의 시간복잡도



### 퀵정렬의 재귀함수 디자인



### 퀵정렬의 구현 1



### 퀵정렬의 구현 2



퀵정렬 구현하기

```c

```

