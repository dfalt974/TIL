# L18

1. ## Graph

#### 그래프 소개

대표적인 자료구조

* 스택(Stack) : Last In First Out
* 큐(Queue) : First In First Out
* 트리(Tree)
* 그래프(Graph)

##### 그래프

* 정점(Node, vertex)과 간선(Edge)으로 이루어진 자료구조
* 차수(Degree) : 정점에 몇 개의 간선이 연결되어 있는가? ex) 노드2의 차수는 4
* 사이클(Cycle) : 자기 자신으로 다시 돌아올 수 있는 경로

##### 그래프는 왜 중요한가?

* 현실 세계의 많은 것들을 그래프로 나타낼 수 있다.

  즉, 그래프와 관련된 문제가 매우 많다.

* 그래프와 관련된 수학적 정리가 매우 많다.

  그래프 이론이라는 분야가 따로 있다 (Graph theory)

* (매우) 어렵다

  그래프와 관련된 이론도 어렵고 구현도 어렵다.



#### 그래프와 관련된 수학적 지식

* 간선의 개수는 정점의 제곱보다 작거나 같다.

  ### |E| <= |V|^2

  |E| 최댓값 = |V|^2 (정점 개수의 제곱) = 1+...+ |V|-1= |V|(|V|-1) / 2

  nC2 = n(n-1)/2 간선의 개수의 최댓값

* 각 정점의 차수의 합은 간선의 개수의 2배와 같다.

  차수의 합을 구할 때, 각 간선을 두 번씩 세기 때문



#### 인접 행렬

그래프의 구현: 인접행렬  /  인접 리스트

* 정점의 연결관계를 2차원 배열에 0, 1로 표현

  0: 연결이 안돼있음  //  1: 연결이 돼있음

Q1. x와 y가 연결이 돼있는가?

Q2. x와 연결된 정점이 모두 무엇인가?



#### 인접 행렬의 장점과 단점

Q1. x와 y가 연결이 돼있는가?

* 장점 : 연결 여부를 O(1)에 알 수 있다.

* 단점 : 인접한 정점을 찾는데 O(n)이 걸린다

  (실제 인접한 정점 수와 관계없이)

  무조건 n^2개의 칸을 써야한다

  (실제 간선의 개수와 관계없이)

  ex) 100개의 정점 / 200개의 간선의 경우 => 100x100=10000개의 칸 필요

  공간의 효율이 좋지 않음



#### 인접 행렬의 구현 1

```c
// 인접행렬을 이용한 그래프의 구현

#include <stdio.h>

const int MAX = 10;

// 5 6   (정점의 개수, 간선의 갯수)
// 1 2   1 --- 2
// 1 3   |\   /
// 1 4   | \ /
// 2 4   3  4 --- 5
// 4 5   ㄴ-------/
// 3 5

int main() {
  int n, m;  // n: 정점의 갯수, m: 간선의 갯수
  int myGraph[MAX][MAX] = {0,};
  
  scanf("%d %d", &n, &m);
  
  for(int i=0; i<m; i++) {
    int a, b;
    
    scanf("%d %d", &a, &b);  // a와 b가 연결이 되어 있다.
    
    myGraph[a][b] = 1;
    myGraph[b][a] = 1;
  }
  
  for(int i=1; i<=n; i++) {
    for(int j=1; j<=n; j++) {
      printf("%d ", myGraph[i][j]);
    }
    
    printf("\n");
  }
  
  return 0;
}
```





#### 인접 행렬의 구현 2



#### 인접 리스트



#### 인접 리스트의 장점과 단점



2. ## Library

#### 라이브러리(Library)



#### STL(Standard Template library)



#### Vector의 개념과 기초 예제



#### Vector의 구현 1



#### Vector의 초기화와 메소드



#### Vector의 구현 2



#### 인접 리스트의 구현



3. ## Graph traversal

#### 그래프 순회의 뜻



#### 그래프 순회의 종류 DFS & BFS



##  4. DFS

#### 깊이 우선 탐색의 철학



#### 깊이 우선 탐색의 예제



#### 깊이 우선 탐색의 퀴즈



#### 깊이 우선 탐색의 전체적 구현



#### 깊이 우선 탐색의 자세한 과정



#### 깊이 우선 탐색의 구현



#### 깊이 우선 탐색의 정확성과 시간복잡도



#### 깊이우선탐색과 너비우선탐색



#### 2색칠하기



#### 이분그래프판별



#### 웜바이러스



#### 단지번호붙이기



