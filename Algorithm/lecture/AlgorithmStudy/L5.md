# L5

1. # 기본 정렬 (Basic Sort)

### 정렬의 개념

* 특정 기준을 적용하여 나열함
  * 오름차순 정렬 : 갈수록 커지는 것
  * 내림차순 정렬 : 갈수록 작아지는 것
  * 절댓값 : 부호 뗀 것

### 정렬의 종류

= 숫자에 특정 기준을 적용하여 나열함. 나열하는 방법이 다름

* 선택정렬
* 삽입정렬
* 버블정렬

### 선택정렬의 개념

* 최솟값을 앞으로 이동시킴 (기준:오름차순)
* 바 - 왼쪽은 정렬이 모두 되어있다는 의미. 오른쪽은 정렬을 해야한다
* 최솟값을 찾아서 옮기고 바를 옮김

### 선택정렬의 구현

* i의 의미 : 이곳에 최솟값을 위치시켜야 한다
* i를 한칸씩 옮기면서 i부터 배열 끝까지 중 최솟값을 찾아서 i에 있는 값과 바꿈

```c
#include <stdio.h>

int main() {
  /*
  10
  1 5 6 8 3 4 5 9 2 10
  ---
  1 2 3 4 5 6 7 8 9 10
  */
  
  int n;
  int data[100];
  
  scanf("%d", &n);
  
  for(int i=0; i<n; i++) {
    scanf("%d", &data[i]);
  }
  
  // 데이터 잘 들어갔는지 확인
  for(int i=0; i<n; i++) {
    printf("%d ", data[i]);
  }
  
  printf("\n");
  
  // i 변수(i : 지금 위치에 최솟값 들어가야한다)를 가지고 오른쪽으로 움직이면서 정렬
  for(int i=0; i<n; i++) {
    // 이제 i번째에 최솟값을 넣어라
    // i번째부터 맨 끝까지의 값 중 최솟값을 찾아서 i번째 값과 바꾸기
    //       i        inx 
    // 1 2 | 6 4 8 3   2   10
    // 최솟값 '위치' inx를 알아야 함
    // i와 inx가 가리키는 값을 바꿔야함
    
    // inx가 가리키는 값이 남은 애들 중 가장 작은 값
    int inx = i;
    for(int j=i; j<n; j++) {
      if(data[inx] > data[j]) {
        inx = j;
      }
    }
    
    int temp;
    temp = data[i];
    data[i] = data[inx];
    data[inx] = temp;
    
    // 매 순간마다 데이터 찍어보기
    for(int j=0; j<n; j++)
      printf("%d ", data[j]);
    
    printf("\n");
  }
  
  // 결과
  for(int i=0; i<n; i++)
    printf("%d ", data[i]);
    
  printf("\n");

  return 0;
}
```

```c
// 주석 생략
#include <stdio.h>

int main() {
  int n;
  int data[100];
  scanf("%d", &n);
  
  for(int i=0; i<n; i++) {
    scanf("%d", &data[i]);
  }
  
  for(int i=0; i<n; i++) {
    int inx = i;
    for(int j=i; j<n; j++) {
      if(data[inx] > data[j]) {
        inx = j;
      }
    }
    
    int temp;
    temp = data[i];
    data[i] = data[inx];
    data[inx] = temp;
  }
  
  for(int i=0; i<n; i++)
    printf("%d ", data[i]);
    
  printf("\n");

  return 0;
}
```

```c
#include <stdio.h>

int main() {
  int n;
  int data[100];
  
  scanf("%d", &n);
  for(int i=0; i<n; i++) {
    scanf("%d", &data[i]);
  }
  
  for(int i=0; i<n; i++) {
    int idx = i;
    for(int j=i; j<n; j++) {
      if (data[idx] > data[j]) {
        idx = j;
      }
    }
    int temp;
    temp = data[i];
    data[i] = data[idx];
    data[idx] = temp;
  }
  
  for(int i=0; i<n; i++) {
    printf("%d ",data[i]);
  }
  
  return 0;
}
```



### 삽입정렬의 개념

* 원소를 차례대로 정렬된 배열에 삽입시킴
* 



### 삽입정렬의 구현



### 버블정렬의 개념



### 버블정렬의 구현



# 2. 시간복잡도 (Time Complexity)

### 시간복잡도의 개념



### 시간복잡도의 예제1



### 시간복잡도의 예제2



### 입력 크기에 따른 수행 시간



### O(n)의 실제 수행 시간



### O(n^2)의 실제 수행 시간



### 수행 시간을 어림짐작하기



### 정렬의 시간복잡도



k번째 큰 수 찾기

```c

```



# 3. 기본 정수론 (Basic Number Theory)

### 정수론 소개



### 약수



### 약수 구하기 구현



### 소수



### 소수 판별 구현



### 에라토스테네스의 체



### 소인수 분해



### 소인수 분해 구현



### 유클리드 호제법



### 최대공약수와 최대공배수 구현



### 파스칼 삼각형



nextnum

```c

```

beehive

```c

```

fibonacci

```c

```

PROSJEK

```c

```

sequencesum

```c

```

combinationpascal

```c

```

combinationzero

```c

```

lcm

```c

```

streetree

```c

```

fractionsum

```c

```

findprime

```c

```

fmttalpha

```c

```

pfactorization

```c

```

chebyshevtheo

```c

```

