# 자료 구조

여러 가지 자료와 정보를 컴퓨터 안에 저장하고 보관하는 방식

알고리즘 문제를 풀려면 주어진 자료를 효율적으로 정리해서 보관해야 하므로 알고리즘과 자료 구조는 굉장히 밀접한 관계



## [13] 회문 찾기 (큐와 스택)

문자열이 회문인지 아닌지 판단하여 회문이면 True, 아니면 False를 결과로 알려주는 알고리즘



### (1) 큐와 스택

두 자료 구조는 '자료를 넣는 동작'과 '자료를 빼는 동작'을 할 수 있으며, 들어간 자료가 일렬로 보관된다는 공통점이 있다. 하지만 자료를 넣고 뺄 때 동작하는 방식이 다르다.

* 큐

  큐(queue)는 '줄 서기'에 비유. 가장 먼저 줄을 선 사람이 가장 먼저 택시를 탐(First In First Out)

  큐에 자료를 한 개 집어넣는 동작을 '인큐(enqueue)', 큐 안에 있는 자료를 한 개 꺼내는 동작을 '디큐(dequeue)'라고 표현.

  들어간 순서 그대로 자료가 나옴

  

* 스택

  스택(stack)은 '접시 쌓기'에 비유. 가장 마지막에 들어간 자료를 가장 먼저 꺼내는 것을 의미(Last In First Out)

  맨 아래에 있는 접시를 꺼내려면 맨 위에 있는 접시부터 하나하나 꺼내야 한다

  스택에 자료를 하나 집어넣는 동작을 '푸시(push)', 스택 안에 있는 자료를 하나 꺼내는 동작을 '팝(pop)'

  들어간 순서와 정반대 순서로 자료가 나옴

  

* 리스트로 큐와 스택 사용하기

  큐와 스택은 자료를 일렬로 보관하는 특징. 파이썬의 리스트를 이용해서 쉽게 만들어 볼 수 있다.

```python
# 큐
qu = []  # 초기화. 빈 리스트를 만듦
qu.append(x)  # 자료 넣기(enqueue). 리스트의 맨 뒤에 자료를 추가
x = qu.pop(0)  # 자료 꺼내기(dequeue). 리스트의 맨 앞(0번 위치)에서 자료를 꺼냄

# 스택
st = []  # 초기화. 빈 리스트를 만듦
st.append(x)  # 자료 넣기(push). 리스트의 맨 뒤에 자료를 추가
x = st.pop()  # 자료 꺼내기(pop). 리스트의 맨 뒤에서 자료를 꺼냄
```



### (2) 회문 찾기 알고리즘

주어진 문장의 문장들을 하나하나 큐와 스택에 넣은 다음 큐와 스택에서 하나씩 자료를 꺼낼 때

큐는 들어간 순서 그대로, 스택은 들어간 순서와 정반대로 문자들이 뽑혀 나옴

회문은 거꾸로 읽어도 같은 글자가 나와야 하므로 큐에서 꺼낸 문자들(원래 순서)이 스택에서 꺼낸 문자들(역순)과 모두 같다면 그 문장은 회문이다.

```python
# 주어진 문장이 회문인지 아닌지 찾기(큐와 스택의 특징을 이용)
# 입력: 문자열 s
# 출력: 회문이면 True, 아니면 False

def palindrome(s):
    # 큐와 스택을 리스트로 정의
    qu = []
    st = []
    # 1단계: 문자열의 알파벳 문자를 각각 큐와 스택에 넣음
    for x in s:
        # 해당 문자가 알파벳이면(공백, 숫자, 특수문자가 아니면)
        # 큐와 스택에 각각 그 문자를 추가
        if x.isalpha():
            qu.append(x.lower())
            st.append(x.lower())
    # 2단계: 큐와 스택에 들어 있는 문자를 꺼내면서 비교
    while qu:  # 큐에 문자가 남아 있는 동안 반복
        if qu.pop(0) != st.pop():  # 큐와 스택에서 꺼낸 문자가 다르면 회문이 아님
            return False

    return True

print(palindrome("WoW"))
print(palindrome("Madam, I'm Adam."))
print(palindrome("Madam, I am Adam."))

'''
True
True
False
'''
```

isalpha() 함수는 주어진 문자가 알파벳 문자에 해당하는지 확인하는 기능

공백, 숫자, 특수문자는 isalpha() 함수로 걸러냄

lower() 함수는 주어진 알파벳을 소문자로 바꿈

문자를 모두 소문자로 바꿔 큐와 스택에 추가하므로 대소문자 구분 없이 회문 판단 가능

* 큐와 스택 이용하지 않고 문장의 앞뒤를 차례로 비교하면서 각 문자가 같은지 확인하는 방법도 있음



### * 리스트를 이용한 큐와 스택의 구현

```python
'''
리스트로 큐와 스택의 동작을 구현하면 다른 모듈을 사용하지 않고도 간단히 큐, 스택 사용 가능하지만 비효율적(큐가 비효율적)
효율성이 중요한 프로그램이라면 파이썬의 collections 모듈에 있는 deque(double-ended queue)를 이용하여 다음과 같은 방식으로 큐를 만들어 사용 가능
'''

from collections import deque
qu = deque()
qu.append(1)  # 1을 큐에 추가(enqueue)
qu.append(2)  # 2를 큐에 추가(enqueue)
qu.popleft()  # 큐에서 1을 꺼냄(dequeue)
# 1
qu
# deque([2])  # 1을 꺼냈으므로 2가 남아 있음
```

큐가 더 비효율적인 이유는 줄 서기를 생각해보면, 큐에서 맨 앞사람이 빠져나가면 줄의 맨 앞이 비게 되고 줄에 남은 모든 사람이 '귀찮게도' 한 발씩 앞으로 움직여야 하기 때문.

1. 리스트로 만든 큐에서 자료 꺼내기(dequeue)

   qu.pop(0) -> 리스트의 0번 위치에서 자료를 빼내면 0번 위치가 비므로 남은 자료를 전부 한칸씩 당겨 주는 처리가 필요

2. 리스트로 만든 스택에서 자료 꺼내기(pop)

   st.pop() -> 리스트의 맨 뒤에서 자료를 빼내면 남은 자료의 위치는 변화가 없음

   

## [14] 동명이인 찾기2 - 딕셔너리

n명의 사람 이름 중에 같은 이름을 찾아 집합으로 만들어 돌려주는 알고리즘

동명이인 찾기 문제는 사람들의 이름이 나열된 리스트 안에 같은 이름이 있는지 확인해서 중복된 이름들을 집합으로 돌려주는 문제. ex) ["Tom", "Jerry", "Mike", "Tom"] => {"Tom"}

파이썬의 딕셔너리(dictionary, 사전)라는 자료 구조를 이용해서 동명이인 문제 풀기



### (1) 딕셔너리

파이썬의 딕셔너리는 정보를 찾는 기준이 되는 키(key)와 그 키에 연결된 값(value)의 대응 관계를 저장하는 자료 구조.

```python
# 정보가 아무것도 들어 있지 않은 빈 딕셔너리를 만들려면 값이 들어 있지 않은 빈 중괄호 또는 dict()를 이용
d = {}
d = dict()
```

딕셔너리에서 키로 원하는 값을 찾으려면 리스트와 마찬가지로 대괄호 안에 키를 적어 주면 됨(리스트에서는 대괄호 안에 원하는 위치 번호)

```python
d = {"Justin": 13, "John": 10, "Mike": 9}
d["Justin"]
# 13
d["John"]
# 10
```

딕셔너리에 없는 키를 대괄호 안에 넣으면 에러가 발생

```python
d["Summer"]
# KeyError: 'Summer'
```

딕셔너리에 새 값을 추가하려면 다음과 같이 값을 대입하면 됨

```python
d["Summer"] = 1
```

이제 "Summer"라는 키에 1이라는 값이 저장

```python
d["Summer"]
# 1
```

* 딕셔너리에는 키가 중복되지 않는다. 이미 존재하는 키에 새 값을 넣으면 기존 값은 지워지고 새 값으로 덮어써진다

```python
d["Summer"] = 2  # 기존 값은 1은 지워지고 2로 바뀜
d["Summer"]
#2
```



```python
s_info = {
    1: "김민준",
    2: "이유진",
    3: "박승규"
}
```

* 학생 번호 2번에 해당하는 학생 이름을 알고 싶다면 s_info[2]
* 새 학생을 학생 명부에 추가하려면 s_info[4] = "최재원"과 같이 학생 번호를 키, 학생 이름을 값으로 대입
* 학생 번호가 3번인 학생(박승규)을 학생 명부에서 삭제하려면 del s_info[3]과 같이 del 명령어 이용

```python
len(a)  # 딕셔너리 길이(자료 개수)를 구함
d[key]  # 딕셔너리에서 키(key)에 해당하는 값을 읽음. 없는 키의 값을 읽으려고 하면 키 에러(KeyError)가 발생
d[key] = value  # 키(key)에 값(value)을 저장. 없다면 새로 만들고 이미 있다면 value 값을 덮어씀
del d[key]  # 키(key)에 해당하는 값을 지움
clear()  # 딕셔너리에 담긴 모든 자료를 지움
key in d  # 키(key)가 딕셔너리 d 안에 있는지 확인(key not in d는 반대 결과)
```



* 집합과 딕셔너리

  파이썬의 집합과 딕셔너리는 서로 다른 자료 구조

  둘 다 중괄호로 자료를 표현.

  단순히 자료만 나열 -> 집합

  키와 값이 콜론(:)으로 연결되어 나열 -> 딕셔너리

  ```python
  s = set()  # 빈 집합 s
  d = dict()  # 빈 딕셔너리 d, d = {}도 같음
  ```



### (2)  딕셔너리를 이용한 동명이인 찾기 알고리즘

딕셔너리 : 정보를 찾는 기준이 되는 키(key)와 그 키에 해당하는 값(value)이 나열된 것

각 이름을 키(key)로, 그 이름이 리스트에 등장한 횟수를 값(value)으로 한 딕셔너리 name_dict을 만들고 이 중 값(value)이 2 이상인 키(key)를 골라내기

1. 각 이름이 등장하는 횟수를 저장할 빈 딕셔너리(name_dict)
2. 입력으로 주어진 리스트에서 각 이름을 꺼내면서 반복
3. 주어진 이름이 name_dict에 있는지 확인
4. 이미 있다면 등장 횟수를 1 증가
5. 아직 없다면 그 이름을 키(key)로 하는 항목을 새로 만들어 1을 저장
6. 1 ~ 5번 과정을 거치면 name_dict에는 리스트에 등장하는 모든 이름과 각각의 등장 횟수가 저장
7. 만들어진 딕셔너리에서 등장 횟수가 2 이상인 이름을 찾아 결과 집합에 넣은 다음 출력으로 돌려줌

```python
# 두 번 이상 나온 이름 찾기
# 입력: 이름이 n개 들어 있는 리스트
# 출력: n개의 이름 중 반복되는 이름의 집합

def find_same_name(a):
    # 1단계: 각 이름이 등장한 횟수를 딕셔너리로 만듦
    name_dict = {}
    for name in a:  # 리스트 a에 있는 자료들을 차례로 반복
        if name in name_dict:  # 이름이 name_dict에 있으면
            name_dict[name] += 1  # 등장 횟수를 1 증가
        else:  # 새 이름이면
            name_dict[name] = 1  # 등장 횟수를 1로 저장
    # 2단계: 만들어진 딕셔너리에서 등장 횟수가 2 이상인 것을 결과에 추가
    result = set()  # 결괏값을 저장할 빈 집합
    for name in name_dict:  # 딕셔너리 name_dict에 있는 자료들을 차례로 반복
        if name_dict[name] >= 2:
            result.add(name)            

    return result
        
name = ["Tom", "Jerry", "Mike", "Tom"]  # 대소문자 유의: 파이썬은 대소문자를 구분
print(find_same_name(name))

name2 = ["Tom", "Jerry", "Mike", "Tom", "Mike"]
print(find_same_name(name2))

'''
{'Tom'}
{'Mike', 'Tom'}
'''
```



### (3) 알고리즘 분석

문제 3에서 살펴본 동명이인 찾는 알고리즘은 리스트 안에 들어 있는 모든 사람을 서로 한 번씩 비교하여 같은 이름이 있는지 찾아내는 방식. 사람 수가 n일 때 계산 복잡도는 O(n제곱)

반면 딕셔너리를 이용한 알고리즘은 1단계로 리스트 정보를 한 번 읽어서 각 이름과 등장 횟수를 딕셔너리에 넣는 동작(n번 처리)을 하고, 2단계로 딕셔너리 안에 저장된 서로 다른 이름을 확인하여 등장 횟수가 2 이상인 자료를 찾는다(n번 이하 처리). 이는 for 반복문을 겹쳐서 사용하지 않고 따로따로 두 번 반복하는 과정이므로 대문자 O 표기법으로 표현하면 O(n)에 해당

프로그램에서 for 반복문이 여러 번 나올 때는 서로 겹치느냐 겹치지 않느냐에 따라 계산 복잡도가 많이 달라짐

```
계산 복잡도: 시간 복잡도와 공간 복잡도
계산 복잡도에는 계산을 얼마나 빨리 할 수 있는지 따져 보는 '시간 복잡도'와 계산에 얼마나 많은 저장 공간이 필요한지 따져 보는 '공간 복잡도'가 있다.
딕셔너리를 이용해 동명이인을 찾는 문제는 모든 사람을 서로 비교하는 방법보다 더 나은 시간 복잡도를 가진다. 하지만 딕셔너리를 만들어 그 안에 모든 이름과 등장 횟수를 저장해야 하므로 더 많은 저장 공간을 사용한다. <= 공간 복잡도를 희생하여 시간 복잡도를 개선한 것
알고리즘 분석을 정확하게 하려면 시간 복잡도뿐만 아니라 공간 복잡도도 함께 고려해야 한다.
하지만 현대 컴퓨터는 대체로 저장 공간(메모리, 하드디스크)이 매우 크기 때문에 상대적으로 공간 복잡도에 덜 민감한 편
```

* 해시 테이블

  파이썬의 딕셔너리와 같이 키(key)와 값(value)을 대응시켜 자료를 보관하는 자료 구조를 컴퓨터 과학 용어로는 '해시 테이블(hash table)'이라고 부름

  해시 테이블은 프로그래밍 언어마다 다른 이름으로 부르기도 한다.

  예를 들어 C++에서는 언오더드맵(unordered_map)이라고 부르고 자바에서는 해시맵(hashmap)

  파이썬/C#에서는 딕셔너리(dictionary, 사전)라는 용어를 사용

  해시 테이블은 키(key)와 값(value)을 대응시켜 여러 개의 자료를 보관하는 효율성이 높은 자료 구조



## [15] 친구의 친구 찾기

친구 관계를 이용하여 어떤 한 사람이 직접 또는 간접으로 아는 모든 친구를 출력하는 알고리즘



### (1) 용어 정리

* 친구(일촌): 어떤 두 사람이 직접 아는 사이일 때, 즉 서로 친구 요청을 수락한 경우 친구라고 함

  ex) A가 B의 친구이면 B도 A의 친구

* 모든 친구(친척): 어떤 사람이 직접 아는 친구들과 그 친구들의 친구들, 즉 직간접으로 아는 모든 사람을 말함(자기 자신도 포함)

  ex) A와 B가 친구이고 B와 C가 친구이고 C와 D가 친구이면(A-B-C-D), A에게는 A, B, C, D 전부가 '모든 친구'

* 친밀도(촌수): 어떤 사람 두 명이 서로 직간접으로 아는 사이일 때 두 명이 서로 몇 단계를 거쳐 아는지 나타내는 숫자(자기 자신의 친밀도는 0)

  ex) A와 B가 친구이고 B와 C가 친구이고 C와 D가 친구이면(A-B-C-D), A와 B의 친밀도는 1, A와 C의 친밀도는 2, A와 D의 친밀도는 3

친구 관계를 이용하여 어떤 한 사람의 '모든 친구'를 출력하는 알고리즘 만들기

위 문제를 푸는 데 꼭 필요한 자료구조인 '그래프(graph)'를 알아보자

 

### (2) 그래프

친구 관계 문제를 푸는 데 필요한 그래프는 꼭짓점들과 그 꼭짓점 사이를 연결한 선의 집합을 의미

꼭짓점(vertex)와 그 꼭짓점 사이를 연결하는 선(edge)



### (3) 그래프로 친구 관계 표현하기



### (4) 파이썬으로 그래프 표현하기

파이썬에서 그래프를 자료 구조로 만들어 저장하는 방법에는 여러 가지가 있지만, 여기서는 우리가 이미 알고 있는 리스트와 딕셔너리를 이용해서 그래프를 표현하는 방법으로.

그래프를 표현하려면 각 꼭짓점의 정보부터 저장해야 한다

그래프를 표현할 fr_info 딕셔너리를 만들고 키(key)로 각 꼭짓점을 지정

```python
fr_info = {
    'Summer':
    'John':
    'Justin':
    'Mike':
    'May':
    'Kim':
    'Tom':
    'Jerry':
}
```

딕셔너리에는 키와 키에 대응하는 값(value)이 필요 => '선'

각 꼭짓점에 직접 연결된 다른 꼭짓점들의 리스트를 만들어서 fr_info의 키에 대응하는 값으로 적기

```python
'Summer': ['John', 'Justin', 'Mike']
```

```python
fr_info = {
    'Summer': ['John', 'Justin', 'Mike'],
    'Jonh': ['Summer', 'Justin'],
    'Justin': ['John', 'Summer', 'Mike', 'May'],
    'Mike': ['Summer', 'Justin'],
    'May': ['Justin', 'Kim'],
    'Kim': ['May'],
    'Tom': ['Jerry'],
    'Jerry': ['Tom']
}
```

A가 B의 친구면 B는 자동으로 A의 친구.

따라서 Summer에 대응하는 리스트에 John이 있으면 John에 대응하는 리스트에도 자연히 Summer가 있음



### (5) 모든 친구 찾기 알고리즘

이 문제를 풀기 위해 메모할 두 가지

1. 앞으로 처리해야 할 사람들 

   꼬리에 꼬리를 무는 친구의 친구들을 한 명도 빠뜨리지 않고 처리하려면 친구의 이름이 나올 때마다 메모지에 적어 두었다가 한 명씩 처리하면서 메모지에서 지워야 함

2. 이미 추가된 사람들

   친구 추적 과정에서 한 명이 여러 번 나오거나 추적이 무한 반복되지 않게 하려면 이미 처리 대상으로 올린 사람은 중복되지 않도록 메모지에 적어 두어야 함

'앞으로 처리해야 할 사람을 넣어 두었다가 하나씩 꺼내기 위한 기억 장소'로 큐(변수 이름: qu) 이용

'이미 처리 대상으로 추가한 사람들을 적어 둘 기억 장소'로 집합(변수 이름: done)을 이용

1. 앞으로 처리할 사람을 저장할 큐(qu)를 만든다
2. 이미 큐에 추가한 사람을 저장할 집합(done)을 만든다
3. 검색의 출발점이 될 사람을 큐(qu)와 집합(done)에 추가
4. 큐에 사람이 남아 있다면 큐에서 처리할 사람을 꺼낸다
5. 꺼낸 사람을 출력
6. 꺼낸 사람의 친구들 중 아직 큐(qu)에 추가된 적이 없는 사람을 골라 큐(qu)와 집합(done)에 추가
7. 큐에 처리할 사람이 남아 있다면 4번 과정부터 다시 반복

```python
# 친구 리스트에서 자신의 모든 친구를 찾는 알고리즘
# 입력: 친구 관계 그래프 g, 모든 친구를 찾을 자신 start
# 출력: 모든 친구의 이름

def print_all_friends(g, start):
    qu = []  # 기억 장소1: 앞으로 처리해야 할 사람들을 큐에 저장
    done = set()  # 기억 장소2: 이미 큐에 추가한 사람들을 집합에 기록(중복 방지)

    qu.append(start)  # 자신을 큐에 넣고 시작
    done.add(start)  # 집합에도 추가

    while qu:  # 큐에 처리할 사람이 남아 있는 동안
        p = qu.pop(0)  # 큐에서 처리 대상을 한 명 꺼내
        print(p)  # 이름을 출력하고
        for x in g[p]:  # 그의 친구들 중에
            if x not in done:  # 아직 큐에 추가된 적이 없는 사람을
                qu.append(x)  # 큐에 추가하고
                done.add(x)  # 집합에도 추가

# 친구 관계 리스트
# A와 B가 친구이면
# A의 친구 리스트에도 B가 나오고, B의 친구 리스트에도 A가 나옴

fr_info = {
    'Summer': ['John', 'Justin', 'Mike'],
    'John': ['Summer', 'Justin'],
    'Justin': ['John', 'Summer', 'Mike', 'May'],
    'Mike': ['Summer', 'Justin'],
    'May': ['Justin', 'Kim'],
    'Kim': ['May'],
    'Tom': ['Jerry'],
    'Jerry': ['Tom']
}

print_all_friends(fr_info, 'Summer')
print()
print_all_friends(fr_info, 'Jerry')
```

그래프에서 연결된 모든 꼭짓점을 탐색하는 알고리즘. '그래프 탐색 알고리즘'



### (6) 친밀도 계산 알고리즘

일반적으로 A라는 사람과 X라는 사람의 친밀도가 n이면 X의 친구 Y는 A와 친밀도가 n+1

이 성질을 이용하여 어떤 사람의 친구들을 큐에 넣을 때 친밀도를 1씩 증가시키면 됨

```python
# 친구 리스트에서 자신의 모든 친구를 찾고 친구들의 친밀도를 계산하는 알고리즘
# 입력: 친구 관계 그래프 g, 모든 친구를 찾을 자신 start
# 출력: 모든 친구의 이름과 자신과의 친밀도

def print_all_friends(g, start):
    qu = []         # 기억 장소1: 앞으로 처리해야 할 (사람 이름, 친밀도) 튜플을 큐에 저장
    done = set()    # 기억 장소2: 이미 큐에 추가한 사람을 집합에 기록(중복 방지)


    qu.append((start, 0))   # (사람 이름, 친밀도) 정보를 하나의 튜플로 묶어 처리
                            # 자기 자신의 친밀도: 0
    done.add(start)         # 집합에도 추가

    while qu:               # 큐에 처리할 사람이 남아 있는 동안
        (p, d) = qu.pop(0)  # 큐에서 (사람 이름, 친밀도) 정보를 p와 d로 각각 꺼냄
        print(p, d)         # 사람 이름과 친밀도를 출력
        for x in g[p]:      # 친구들 중에
            if x not in done:           # 아직 큐에 추가된 적이 없는 사람을
                qu.append((x, d + 1))   # 친밀도를 1 증가시켜 큐에 추가하고
                done.add(x)             # 집합에도 추가

# 친구 관계 리스트
# A와 B가 친구이면
# A의 친구 리스트에도 B가 나오고, B의 친구 리스트에도 A가 나옴

fr_info = {
    'Summer': ['John', 'Justin', 'Mike'],
    'John': ['Summer', 'Justin'],
    'Justin': ['John', 'Summer', 'Mike', 'May'],
    'Mike': ['Summer', 'Justin'],
    'May': ['Justin', 'Kim'],
    'Kim': ['May'],
    'Tom': ['Jerry'],
    'Jerry': ['Tom']
}

print_all_friends(fr_info, 'Summer')
print()
print_all_friends(fr_info, 'Jerry')
```

* 파이썬의 튜플

  프로그램에서는 처리해야 할 사람 이름과 친밀도를 같이 묶어서 큐에 보관하기 위해 파이썬의 튜플(tuple) 기능을 활용.

  튜플은 여러 개의 정보를 묶어서 하나의 정보처럼 사용하기 위한 기능.

  수학에서 x 좌표와 y 좌표를 묶어서 순서쌍 (x, y)로 표현하는 것과 비슷한 개념

  튜플로 묶어서 보관하고자 하는 정보가 있다면 소괄호 안에 쉼표(,)를 찍어 나열하면 됨

  ```python
  t = (3, 7)  # 3과 7을 하나로 묶어 튜플 1에 저장
  t
  # (3, 7)
  t[0]  # 튜플 t의 첫 번째 정보 값
  # 3
  t[1]  # 튜플 t의 두 번째 정보 값
  # 7
  (x, y) = t  # 튜플 t 안의 값들을 변수 x와 y에 각각 저장
  x
  # 3
  y
  # 7
  ```

  qu.append((start, 0))에서 소괄호가 두 번 사용된 이유는 append() 함수의 인자로 start와 0을 묶어 만든 튜플(start, 0)을 전달했기 때문

  또한 (p, d) = qu.pop(0)은 이렇게 저장된 튜플을 꺼내서 사람 이름과 친밀도 정보를 각각 p와 d에 나누어서 저장한다