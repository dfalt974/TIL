# 자료 구조

여러 가지 자료와 정보를 컴퓨터 안에 저장하고 보관하는 방식

알고리즘 문제를 풀려면 주어진 자료를 효율적으로 정리해서 보관해야 하므로 알고리즘과 자료 구조는 굉장히 밀접한 관계



## [13] 회문 찾기 (큐와 스택)

문자열이 회문인지 아닌지 판단하여 회문이면 True, 아니면 False를 결과로 알려주는 알고리즘



### (1) 큐와 스택

두 자료 구조는 '자료를 넣는 동작'과 '자료를 빼는 동작'을 할 수 있으며, 들어간 자료가 일렬로 보관된다는 공통점이 있다. 하지만 자료를 넣고 뺄 때 동작하는 방식이 다르다.

* 큐

  큐(queue)는 '줄 서기'에 비유. 가장 먼저 줄을 선 사람이 가장 먼저 택시를 탐(First In First Out)

  큐에 자료를 한 개 집어넣는 동작을 '인큐(enqueue)', 큐 안에 있는 자료를 한 개 꺼내는 동작을 '디큐(dequeue)'라고 표현.

  들어간 순서 그대로 자료가 나옴

  

* 스택

  스택(stack)은 '접시 쌓기'에 비유. 가장 마지막에 들어간 자료를 가장 먼저 꺼내는 것을 의미(Last In First Out)

  맨 아래에 있는 접시를 꺼내려면 맨 위에 있는 접시부터 하나하나 꺼내야 한다

  스택에 자료를 하나 집어넣는 동작을 '푸시(push)', 스택 안에 있는 자료를 하나 꺼내는 동작을 '팝(pop)'

  들어간 순서와 정반대 순서로 자료가 나옴

  

* 리스트로 큐와 스택 사용하기

  큐와 스택은 자료를 일렬로 보관하는 특징. 파이썬의 리스트를 이용해서 쉽게 만들어 볼 수 있다.

```python
# 큐
qu = []  # 초기화. 빈 리스트를 만듦
qu.append(x)  # 자료 넣기(enqueue). 리스트의 맨 뒤에 자료를 추가
x = qu.pop(0)  # 자료 꺼내기(dequeue). 리스트의 맨 앞(0번 위치)에서 자료를 꺼냄

# 스택
st = []  # 초기화. 빈 리스트를 만듦
st.append(x)  # 자료 넣기(push). 리스트의 맨 뒤에 자료를 추가
x = st.pop()  # 자료 꺼내기(pop). 리스트의 맨 뒤에서 자료를 꺼냄
```



### (2) 회문 찾기 알고리즘

주어진 문장의 문장들을 하나하나 큐와 스택에 넣은 다음 큐와 스택에서 하나씩 자료를 꺼낼 때

큐는 들어간 순서 그대로, 스택은 들어간 순서와 정반대로 문자들이 뽑혀 나옴

회문은 거꾸로 읽어도 같은 글자가 나와야 하므로 큐에서 꺼낸 문자들(원래 순서)이 스택에서 꺼낸 문자들(역순)과 모두 같다면 그 문장은 회문이다.

```python
# 주어진 문장이 회문인지 아닌지 찾기(큐와 스택의 특징을 이용)
# 입력: 문자열 s
# 출력: 회문이면 True, 아니면 False

def palindrome(s):
    # 큐와 스택을 리스트로 정의
    qu = []
    st = []
    # 1단계: 문자열의 알파벳 문자를 각각 큐와 스택에 넣음
    for x in s:
        # 해당 문자가 알파벳이면(공백, 숫자, 특수문자가 아니면)
        # 큐와 스택에 각각 그 문자를 추가
        if x.isalpha():
            qu.append(x.lower())
            st.append(x.lower())
    # 2단계: 큐와 스택에 들어 있는 문자를 꺼내면서 비교
    while qu:  # 큐에 문자가 남아 있는 동안 반복
        if qu.pop(0) != st.pop():  # 큐와 스택에서 꺼낸 문자가 다르면 회문이 아님
            return False

    return True

print(palindrome("WoW"))
print(palindrome("Madam, I'm Adam."))
print(palindrome("Madam, I am Adam."))

'''
True
True
False
'''
```

isalpha() 함수는 주어진 문자가 알파벳 문자에 해당하는지 확인하는 기능

공백, 숫자, 특수문자는 isalpha() 함수로 걸러냄

lower() 함수는 주어진 알파벳을 소문자로 바꿈

문자를 모두 소문자로 바꿔 큐와 스택에 추가하므로 대소문자 구분 없이 회문 판단 가능

* 큐와 스택 이용하지 않고 문장의 앞뒤를 차례로 비교하면서 각 문자가 같은지 확인하는 방법도 있음



### * 리스트를 이용한 큐와 스택의 구현

```python
'''
리스트로 큐와 스택의 동작을 구현하면 다른 모듈을 사용하지 않고도 간단히 큐, 스택 사용 가능하지만 비효율적(큐가 비효율적)
효율성이 중요한 프로그램이라면 파이썬의 collections 모듈에 있는 deque(double-ended queue)를 이용하여 다음과 같은 방식으로 큐를 만들어 사용 가능
'''

from collections import deque
qu = deque()
qu.append(1)  # 1을 큐에 추가(enqueue)
qu.append(2)  # 2를 큐에 추가(enqueue)
qu.popleft()  # 큐에서 1을 꺼냄(dequeue)
# 1
qu
# deque([2])  # 1을 꺼냈으므로 2가 남아 있음
```

큐가 더 비효율적인 이유는 줄 서기를 생각해보면, 큐에서 맨 앞사람이 빠져나가면 줄의 맨 앞이 비게 되고 줄에 남은 모든 사람이 '귀찮게도' 한 발씩 앞으로 움직여야 하기 때문.

1. 리스트로 만든 큐에서 자료 꺼내기(dequeue)

   qu.pop(0) -> 리스트의 0번 위치에서 자료를 빼내면 0번 위치가 비므로 남은 자료를 전부 한칸씩 당겨 주는 처리가 필요

2. 리스트로 만든 스택에서 자료 꺼내기(pop)

   st.pop() -> 리스트의 맨 뒤에서 자료를 빼내면 남은 자료의 위치는 변화가 없음

   

## [14] 동명이인 찾기2 - 딕셔너리

n명의 사람 이름 중에 같은 이름을 찾아 집합으로 만들어 돌려주는 알고리즘

동명이인 찾기 문제는 사람들의 이름이 나열된 리스트 안에 같은 이름이 있는지 확인해서 중복된 이름들을 집합으로 돌려주는 문제. ex) ["Tom", "Jerry", "Mike", "Tom"] => {"Tom"}

파이썬의 딕셔너리(dictionary, 사전)라는 자료 구조를 이용해서 동명이인 문제 풀기



### (1) 딕셔너리

파이썬의 딕셔너리는 정보를 찾는 기준이 되는 키(key)와 그 키에 연결된 값(value)의 대응 관계를 저장하는 자료 구조.

```python
# 정보가 아무것도 들어 있지 않은 빈 딕셔너리를 만들려면 값이 들어 있지 않은 빈 중괄호 또는 dict()를 이용
d = {}
d = dict()
```

딕셔너리에서 키로 원하는 값을 찾으려면 리스트와 마찬가지로 대괄호 안에 키를 적어 주면 됨(리스트에서는 대괄호 안에 원하는 위치 번호)

```python
d = {"Justin": 13, "John": 10, "Mike": 9}
d["Justin"]
# 13
d["John"]
# 10
```

딕셔너리에 없는 키를 대괄호 안에 넣으면 에러가 발생

```python
d["Summer"]
# KeyError: 'Summer'
```

딕셔너리에 새 값을 추가하려면 다음과 같이 값을 대입하면 됨

```python
d["Summer"] = 1
```

이제 "Summer"라는 키에 1이라는 값이 저장

```python
d["Summer"]
# 1
```

* 딕셔너리에는 키가 중복되지 않는다. 이미 존재하는 키에 새 값을 넣으면 기존 값은 지워지고 새 값으로 덮어써진다

```python
d["Summer"] = 2  # 기존 값은 1은 지워지고 2로 바뀜
d["Summer"]
#2
```



```python
s_info = {
    1: "김민준",
    2: "이유진",
    3: "박승규"
}
```

* 학생 번호 2번에 해당하는 학생 이름을 알고 싶다면 s_info[2]
* 새 학생을 학생 명부에 추가하려면 s_info[4] = "최재원"과 같이 학생 번호를 키, 학생 이름을 값으로 대입
* 학생 번호가 3번인 학생(박승규)을 학생 명부에서 삭제하려면 del s_info[3]과 같이 del 명령어 이용

```python
len(a)  # 딕셔너리 길이(자료 개수)를 구함
d[key]  # 딕셔너리에서 키(key)에 해당하는 값을 읽음. 없는 키의 값을 읽으려고 하면 키 에러(KeyError)가 발생
d[key] = value  # 키(key)에 값(value)을 저장. 없다면 새로 만들고 이미 있다면 value 값을 덮어씀
del d[key]  # 키(key)에 해당하는 값을 지움
clear()  # 딕셔너리에 담긴 모든 자료를 지움
key in d  # 키(key)가 딕셔너리 d 안에 있는지 확인(key not in d는 반대 결과)
```



* 집합과 딕셔너리

  파이썬의 집합과 딕셔너리는 서로 다른 자료 구조

  둘 다 중괄호로 자료를 표현.

  단순히 자료만 나열 -> 집합

  키와 값이 콜론(:)으로 연결되어 나열 -> 딕셔너리

  ```python
  s = set()  # 빈 집합 s
  d = dict()  # 빈 딕셔너리 d, d = {}도 같음
  ```



### (2)  딕셔너리를 이용한 동명이인 찾기 알고리즘

딕셔너리 : 정보를 찾는 기준이 되는 키(key)와 그 키에 해당하는 값(value)이 나열된 것

각 이름을 키(key)로, 그 이름이 리스트에 등장한 횟수를 값(value)으로 한 딕셔너리 name_dict을 만들고 이 중 값(value)이 2 이상인 키(key)를 골라내기

1. 각 이름이 등장하는 횟수를 저장할 빈 딕셔너리(name_dict)
2. 입력으로 주어진 리스트에서 각 이름을 꺼내면서 반복
3. 주어진 이름이 name_dict에 있는지 확인
4. 이미 있다면 등장 횟수를 1 증가
5. 아직 없다면 그 이름을 키(key)로 하는 항목을 새로 만들어 1을 저장
6. 1 ~ 5번 과정을 거치면 name_dict에는 리스트에 등장하는 모든 이름과 각각의 등장 횟수가 저장
7. 만들어진 딕셔너리에서 등장 횟수가 2 이상인 이름을 찾아 결과 집합에 넣은 다음 출력으로 돌려줌

```python
# 두 번 이상 나온 이름 찾기
# 입력: 이름이 n개 들어 있는 리스트
# 출력: n개의 이름 중 반복되는 이름의 집합

def find_same_name(a):
    # 1단계: 각 이름이 등장한 횟수를 딕셔너리로 만듦
    name_dict = {}
    for name in a:  # 리스트 a에 있는 자료들을 차례로 반복
        if name in name_dict:  # 이름이 name_dict에 있으면
            name_dict[name] += 1  # 등장 횟수를 1 증가
        else:  # 새 이름이면
            name_dict[name] = 1  # 등장 횟수를 1로 저장
    # 2단계: 만들어진 딕셔너리에서 등장 횟수가 2 이상인 것을 결과에 추가
    result = set()  # 결괏값을 저장할 빈 집합
    for name in name_dict:  # 딕셔너리 name_dict에 있는 자료들을 차례로 반복
        if name_dict[name] >= 2:
            result.add(name)            

    return result
        
name = ["Tom", "Jerry", "Mike", "Tom"]  # 대소문자 유의: 파이썬은 대소문자를 구분
print(find_same_name(name))

name2 = ["Tom", "Jerry", "Mike", "Tom", "Mike"]
print(find_same_name(name2))

'''
{'Tom'}
{'Mike', 'Tom'}
'''
```



### (3) 알고리즘 분석

문제 3에서 살펴본 동명이인 찾는 알고리즘은 리스트 안에 들어 있는 모든 사람을 서로 한 번씩 비교하여 같은 이름이 있는지 찾아내는 방식. 사람 수가 n일 때 계산 복잡도는 O(n제곱)

반면 딕셔너리를 이용한 알고리즘은 1단계로 리스트 정보를 한 번 읽어서 각 이름과 등장 횟수를 딕셔너리에 넣는 동작(n번 처리)을 하고, 2단계로 딕셔너리 안에 저장된 서로 다른 이름을 확인하여 등장 횟수가 2 이상인 자료를 찾는다(n번 이하 처리). 이는 for 반복문을 겹쳐서 사용하지 않고 따로따로 두 번 반복하는 과정이므로 대문자 O 표기법으로 표현하면 O(n)에 해당

프로그램에서 for 반복문이 여러 번 나올 때는 서로 겹치느냐 겹치지 않느냐에 따라 계산 복잡도가 많이 달라짐

