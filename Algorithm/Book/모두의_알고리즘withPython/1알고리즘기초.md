# Algorithm

* 어떤 문제를 풀기 위한 절차나 방법
* 주어진 '입력'을 '출력(답)'으로 만드는 과정
* 각 단계는 구체적이고 명료
  * 컴퓨터 프로그램을 만들기 위한 알고리즘은 계산 과정을 최대한 구체적이고 명료하게

한 가지 문제를 푸는 여러 가지 방법, 즉 여러 가지 알고리즘 중 상황에 맞는 적당한 알고리즘을 골라 쓰려면 어떤 알고리즘이 어떤 특징을 지니고 있으며 얼마나 계산이 빠르고 편한지 알아야 함

'알고리즘 분석' : 알고리즘의 성능이나 특징을 분석하는 것

```python
import math  # 수학 모듈 사용

# 절댓값 알고리즘 1(부호 판단)
# 입력: 실수 a
# 출력: a의 절댓값

def abs_sign(a):
    if a >= 0:
        return a
    else:
        return -a

# 절댓값 알고리즘 2(제곱-제곱근)
# 입력: 실수 a
# 출력: a의 절댓값

def abs_square(a):
    b = a * a
    return math.sqrt(b)  # 수학 모듈의 제곱근 함수


print(abs_sign(5))
print(abs_sign(-3))
print()
print(abs_square(5))
print(abs_square(-3))


'''
5
3

5.0
3.0
'''
```



## 1. 알고리즘 기초

## [1]  1부터 n까지의 합 구하기

### (1) 알고리즘의 중요 포인트

* 문제

  알고리즘은 주어진 문제를 풀기 위한 절차나 방법이므로, 알고리즘이 있으려면 반드시 문제가 필요.

  ex) '1부터 n까지 연속한 숫자의 합 구하기'

* 입력

  알고리즘은 주어진 '입력'을 '출력'으로 만드는 과정

  ex) 입력은 'n까지'에 해당하는 n

  n을 입력으로 하는 문제를 만들면 만들어진 알고리즘으로 다양한 입력에 대한 결과를 얻을 수 있음

* 출력

  ex) n = 10이면 1부터 10까지의 합은 55, n = 100이면 1부터 100까지의 합은 5050

  55와 5050이 각각의 입력에 대한 출력

  

### (2) 구체적이고 명료한 계산 과정

사람과 달리 컴퓨터는 주어진 명령을 기계적으로 수행하는 장치이므로 기계가 알아들을 수 있는 명료하고 구체적인 알고리즘이 있어야만 문제를 풀 수 있음



### (3) 1부터 n까지의 합을 구하는 알고리즘

1. 합을 기록할 변수 s를 만들고 0을 저장
2. 변수 i를 만들어 1부터 n까지의 숫자를 1씩 증가시키며 반복
3. [반복 블록] 기존의 s에 i를 더하여 얻은 값을 다시 s에 저장
4. 반복이 끝났을 때 s에 저장된 값이 결괏값

* 알고리즘을 하나의 함수로 만들어 입력은 인자로 전달하고, 출력은 함수의 결괏값(return 값)으로 만들면, 알고리즘이 '입력 -> 알고리즘 -> 출력'을 수행하는 과정이라는 것을 더 직관적으로 이해할 수 있음

```python
# 1부터 n까지 연속한 숫자의 합을 구하는 알고리즘1
# 입력: n
# 출력: 1부터 n까지의 숫자를 더한 값

def sum_n(n):
    s = 0                       # 합을 계산할 변수
    for i in range(1, n+1):     # 1부터 n까지 반복(n+1은 제외)
        s = s+i
    return s

print(sum_n(10))                # 1부터 10까지의 합(입력: 10, 출력: 55)
print(sum_n(100))               # 1부터 100까지의 합(입력: 100, 출력: 5050)

'''
55
5050
'''
```



### (4) 알고리즘 분석

가우스의 발견을 일반화해서 만든 1부터  n까지의 합 공식

n(n+1)/2

이 공식을 이용해 '1부터 n까지 연속한 숫자의 합 구하기' 문제를 푸는 파이썬 프로그램

```python
# 1부터 n까지 연속한 숫자의 합을 구하는 알고리즘 2
# 입력: n
# 출력: 1부터 n까지의 숫자를 더한 값

def sum_n(n):
    return n*(n+1)//2  # 슬래시 두 개(//)는 정수 나눗셈을 의미


print(sum_n(10))    # 1부터 10까지의 합(입력: 10, 출력: 55)
print(sum_n(100))   # 1부터 100까지의 합(입력: 100, 출력: 5050)


'''
55
5050
'''
```

'알고리즘 분석' <- 주어진 문제를 푸는 여러 가지 방법 중 어떤 방법이 더 좋은 것인지 판단할 때 필요



### (5) 입력 크기와 계산 횟수

알고리즘에는 입력이 필요한데 입력 크기가 알고리즘 수행 성능에 영향을 미칠 때가 많다.

* 첫 번째 알고리즘 : 덧셈 n번
* 두 번째 알고리즘 : 덧셈, 곱셈, 나눗셈 각 한 번(총 세 번)

입력 크기 n이 작을 때는 큰 차이가 없지만 알고리즘 분석에서는 매우 큰 n에 대해서 따져보아야 한다.



### (6) 대문자 O 표기법: 계산 복잡도 표현

'계산 복잡도(complexity)' : 어떤 알고리즘이 문제를 풀기 위해 해야 하는 계산이 얼마나 복잡한지 나타낸 정도

'빅 오' 표기법 : 대문자 O 표기법은 알고리즘에서 필요한 계산 횟수를 정확한 숫자로 표현하지 않고 입력 크기 n과의 관계로 표현. 알고리즘의 대략적인 성능을 표시하는 방법. 

* 필요한 계산 횟수가 입력 크기에 '비례' : O(n)
* 입력 크기 n과 필요한 계산의 횟수가 무관 : O(1)

첫 번째 알고리즘은 입력 크기 n에 대해 사칙 연산(덧셈)을 n번 해야 하므로, 이 알고리즘의 계산 복잡도는 O(n). 필요한 계산 횟수가 입력 크기에 '정비례'할 때 O(n)

두 번째 알고리즘은 입력 크기 n과 무관하게 사칙연산을 세 번 하므로 O(1)

```
알고리즘의 계산 복잡도는 시간 복잡도(time complexity)와 공간 복잡도(space complexity)로 나눌 수 있다.
시간 복잡도 : 어떤 알고리즘을 수행하는 데 얼마나 오랜 시간이 걸리는지 분석
공간 복잡도 : 어떤 알고리즘을 수행하는 데 얼마나 많은 공간(메모리/기억 장소)이 필요한지 분석

앞서 사칙연산 횟수로 계산 복잡도를 생각한 것은 '시간 복잡도'에 해당
어떤 알고리즘을 수행하는 데 필요한 사칙연산의 횟수가 많아지면 결국 알고리즘 전체를 수행하는 시간이 늘어나므로.
책에 나오는 '계산 복잡도'는 특별한 말 없으면 '시간 복잡도'
```



## [2] 최댓값 찾기

### (1) 리스트

주어진 숫자 n개 중 가장 큰 숫자 찾는 알고리즘

* 필요한 파이썬 리스트 기능

```
리스트(list) : 정보 여러 개를 하나로 묶어 저장하고 관리. 대괄호[] 안에 정보 여러개를 ,로 구분
숫자 여러개는 파이썬의 리스트 기능을 이용하면 쉽게 관리 가능

* 자료 위치를 1이 아닌 0부터 센다
* 위치 번호 -1은 리스트의 끝에서 첫 번째 값, 즉 마지막 값
ex) 자료 n개 든 리스트 b에서 마지막 값은 b[n-1] 또는 b[-1]
```

* len() 함수 : 리스트 안에 들어 있는 자료 개수(리스트의 길이) len(a), len( [1, 2, 3] )

* append(x) : 자료 x를 리스트의 맨 뒤에 추가 a.append(4)

* insert(i, x) : 리스트의 i번 위치에 x를 추가 a.insert(0, 5)  # 0번 위치(맨 앞)에 5 추가

* pop(i) : i번 위치에 있는 자료를 리스트에서 빼내면서 그 값을 함수의 결괏값으로 돌려줌. i 지정하지 않으면 맨 마지막 값 print(a.pop())

* clear() : 리스트의 모든 자료 지우기

* x in a : 어떤 자료 x가 리스트 a 안에 있는지 확인(x not in a는 반대 결과) True / False

  

### (2) 최댓값을 찾는 알고리즘

17, 92, 18, 33, 58, 7, 33, 42

1. 첫 번째 숫자 17을 최댓값으로 기억(최댓값: 17)
2. 두 번째 숫자 92를 현재 최댓값 17과 비교. 92는 17보다 크므로 최댓값을 92로 바꿔 기억(최댓값: 92)
3. 세 번째 숫자 18을 현재 최댓값 92와 비교. 18은 92보다 작으므로 지나간다(최댓값: 92)

4~7. 네 번째 숫자부터 일곱 번째 숫자까지 같은 과정 반복

8. 마지막 숫자 42를 현재 최댓값 92와 비교. 42는 92보다 작으므로 지나간다(최댓값: 92)
9. 마지막으로 기억된 92가 주어진 숫자 중 최댓값

```python
# 최댓값 구하기
# 입력: 숫자가 n개 들어 있는 리스트
# 출력: 숫자 n개 중 최댓값

def find_max(a):
    n = len(a)              # 입력 크기 n
    max_v = a[0]            # 리스트의 첫 번째 값을 최댓값으로 기억
    for i in range(1, n):   # 1부터 n-1까지 반복
        if a[i] > max_v:    # 이번 값이 현재까지 기억된 최댓값보다 크면
            max_v = a[i]    # 최댓값을 변경
    return max_v


v = [17, 92, 18, 33, 58, 7, 33, 42]
print(find_max(v))


'''
92
'''
```



### (3) 알고리즘 분석

최댓값 구하기 프로그램의 계산 복잡도(시간 복잡도)는, 입력 크기가 n일 때, 즉 숫자 n개 중에서 최댓값을 구할 경우 자료 개수 n은 리스트 a의 크기인 len(a)

최댓값을 구하는데 컴퓨터가 해야 하는 가장 중요한 계산은 두 값 중 어느 것이 더 큰지 판단하는 '비교'

for i in range(1, n): 반복문 안에 크기를 비교하는 판단 구문(if a[i] > max_v:)이 있어 자료 n개 중 최댓값을 찾으려면 비교를 n-1번 해야 함

O(n)

계산 복잡도 O(n)의 가장 중요한 특징은 입력 크기와 계산 시간이 대체로 비례한다는 것.

숫자 10,000개 중 최댓값을 찾는 데 걸리는 시간이 10초면 20,000개를 입력할 때 약 20초 예상



### (4)  응용하기

리스트에 숫자가 n개 있을 때 가장 큰 값이 있는 위치 번호를 돌려주는 알고리즘

```python
# 최댓값의 위치 구하기
# 입력: 숫자가 n개 들어 있는 리스트
# 출력: 숫자 n개 중에서 최댓값이 있는 위치(0부터 n-1까지의 값)

def find_max_idx(a):
    n = len(a)  # 입력 크기n
    max_idx = 0  # 리스트 중 0번 위치를 최댓값 위치로 기억
    for i in range(1, n):
        if a[i] > a[max_idx]:  # 이번 값이 현재까지 기억된 최댓값보다 크면
            max_idx = i  # 최댓값의 위치를 변경
    return max_idx

v = [17, 92, 18, 33, 58, 7, 33, 42]
print(find_max_idx(v))


'''
1
'''
```

최댓값 또는 최솟값 위치 번호를 알면 값 쉽게 구할 수 있다.

a[최댓값의 위치 번호] = 최댓값



## [3] 동명이인 찾기1

n명의 사람 이름 중에서 같은 이름을 찾아 집합으로 만들어 돌려주는 알고리즘

### (1) 집합

집합은 리스트와 같이 정보를 여러 개 넣어서 보관할 수 있는 파이썬 기능인데, 리스트와 달리 자료가 중복되어 들어가지 않고, 자료의 순서도 의미가 없다.

빈 집합을 만들려면 set()을 이용하고, 집합에 자료를 추가하려면 add() 함수를 이용

집합 안에 자료가 몇 개 있는지 알려면 len() 함수를 이용

* len(s) : 집합의 길이(자료 개수)를 구함
* add(x) : 집합에 자료 x를 추가
* discard(x) : 집합에 자료 x가 들어 있다면 삭제(없으면 변화X)
* clear() : 집합의 모든 자료를 지움
* x in s : 어떤 자료 x가 집합 s에 들어 있는지 확인(x not in s는 반대 결과)

### (2) 동명이인을 찾는 알고리즘

name = ["Tom", "Jerry", "Mike", "Tom"]  # 파이썬은 대소문자 구분

1. 첫 번째 Tom을 뒤에 있는 Jerry, Mike, Tom과 차례로 비교
2. 첫 번째 Tom과 마지막 Tom이 같으므로 동명이인(동명이인: Tom)
3. 두 번째 Jerry를 뒤에 있는 Mike, Tom과 비교(앞에 있는 Tom과는 이미 비교했음)
4. 세 번째 Mike를 뒤에 있는 Tom과 비교
5. 마지막 Tom은 비교하지 않아도 됨(이미 앞에서 비교)
6. 같은 이름은 Tom 하나뿐

주의할 점

* 이번에 비교할 이름을 뽑은 다음에는 뽑은 이름보다 순서상 뒤에 있는 이름하고만 비교하면 됨

  자기 자신과 비교하는 것은 무의미하고 앞에 있는 이름과는 이미 비교가 끝났기 때문

* 리스트의 마지막 이름을 기준으로는 비교하지 않아도 됨. 자신의 뒤에는 비교할 이름이 없고, 앞과는 이미 비교가 끝나서

* 같은 이름을 찾으면 결과 집합에 그 이름을 추가

```python
# 두 번 이상 나온 이름 찾기
# 입력: 이름이 n개 들어 있는 리스트
# 출력: 이름 n개 중 반복되는 이름의 집합

def find_same_name(a):
    n = len(a)  # 리스트의 자료 개수를 n에 저장
    result = set()  # 결과를 저장할 빈 집합
    for i in range(0, n-1):  # 0부터 n~2까지 반복
        for j in range(i+1, n):  # i+1부터 n-1까지 반복
            if a[i] == a[j]:  # 이름이 같으면
                result.add(a[i])  # 찾은 이름을 result에 추가
    return result

name = ["Tom", "Jerry", "Mike", "Tom"]  # 대소문자 유의: 파이썬은 대소문자를 구분함
print(find_same_name(name))
name2 = ["Tom", "Jerry", "Mike", "Tom", "Mike"]
print(find_same_name(name2))


'''
{'Tom'}
{'Mike', 'Tom'}
'''
```

집합에서는 어떤 자료가 집합에 들어 있는지가 중요할 뿐 그 자료들의 순서는 중요하지 않다.

위에서 중첩된 반복문을 보면, 리스트 안에 있는 자료를 서로 빠짐없이 비교하되 중복해서 비교하지 않도록 반복문을 두 개 겹쳐서 사용했다.

첫 번째 반복문 for i in range(0, n-1): 은 i를 0부터 n-2까지 반복한다는 뜻이며, 

리스트의 마지막 값에 해당하는 a[n-1]은 이미 앞에서 다른 자료와 한 번씩 다 비교했으므로 제외해도 된다.

두 번째 반복문 for j in range(i+1, n): 은 비교 기준으로 정해진 i번째 위치에 1을 더한 위치의 값부터 끝까지 비교하는 것이다.

### (3) 알고리즘 분석

위 알고리즘의 계산 복잡도는 같은 이름을 찾는 알고리즘이므로 두 이름이 같은지 '비교'하는 횟수를 따져보면 된다.

입력 크기 n에 대하여

0번 위치 이름: n-1번 비교(자기를 제외한 모든 이름과 비교)

1번 위치 이름: n-2번 비교

2번 위치 이름: n-3번 비교

...

n-2번 위치 이름: 1번 비교

n-1번 위치 이름: 0번 비교

전체 비교 횟수는 0 + 1 + 2 + ... + (n-1)번, 즉 1부터 n-1까지의 합

문제 1에서 배운 1부터 n까지의 합을 구하는 공식에 n 대신 n-1을 대입하면 다음과 같다.

1 + 2 + ... + (n-1) = (n-1)(n-1+1)/2 = n(n-1)/2 = 1/2n^-1/2n번 비교해야 한다

O(n제곱)  <- 입력크기 n이 커지면 계산 시간은 그 제곱에 비례하므로 엄청난 차이로 증가

n의 제곱에 비례해서 계산 시간이 변하는 것이 핵심이므로 계수 무시