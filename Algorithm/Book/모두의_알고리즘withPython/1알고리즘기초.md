# Algorithm

* 어떤 문제를 풀기 위한 절차나 방법
* 주어진 '입력'을 '출력(답)'으로 만드는 과정
* 각 단계는 구체적이고 명료
  * 컴퓨터 프로그램을 만들기 위한 알고리즘은 계산 과정을 최대한 구체적이고 명료하게

한 가지 문제를 푸는 여러 가지 방법, 즉 여러 가지 알고리즘 중 상황에 맞는 적당한 알고리즘을 골라 쓰려면 어떤 알고리즘이 어떤 특징을 지니고 있으며 얼마나 계산이 빠르고 편한지 알아야 함

'알고리즘 분석' : 알고리즘의 성능이나 특징을 분석하는 것

```python
import math  # 수학 모듈 사용

# 절댓값 알고리즘 1(부호 판단)
# 입력: 실수 a
# 출력: a의 절댓값

def abs_sign(a):
    if a >= 0:
        return a
    else:
        return -a

# 절댓값 알고리즘 2(제곱-제곱근)
# 입력: 실수 a
# 출력: a의 절댓값

def abs_square(a):
    b = a * a
    return math.sqrt(b)  # 수학 모듈의 제곱근 함수


print(abs_sign(5))
print(abs_sign(-3))
print()
print(abs_square(5))
print(abs_square(-3))


'''
5
3

5.0
3.0
'''
```



## 1. 알고리즘 기초

## [1]  1부터 n까지의 합 구하기

### (1) 알고리즘의 중요 포인트

* 문제

  알고리즘은 주어진 문제를 풀기 위한 절차나 방법이므로, 알고리즘이 있으려면 반드시 문제가 필요.

  ex) '1부터 n까지 연속한 숫자의 합 구하기'

* 입력

  알고리즘은 주어진 '입력'을 '출력'으로 만드는 과정

  ex) 입력은 'n까지'에 해당하는 n

  n을 입력으로 하는 문제를 만들면 만들어진 알고리즘으로 다양한 입력에 대한 결과를 얻을 수 있음

* 출력

  ex) n = 10이면 1부터 10까지의 합은 55, n = 100이면 1부터 100까지의 합은 5050

  55와 5050이 각각의 입력에 대한 출력

  

### (2) 구체적이고 명료한 계산 과정

사람과 달리 컴퓨터는 주어진 명령을 기계적으로 수행하는 장치이므로 기계가 알아들을 수 있는 명료하고 구체적인 알고리즘이 있어야만 문제를 풀 수 있음



### (3) 1부터 n까지의 합을 구하는 알고리즘

1. 합을 기록할 변수 s를 만들고 0을 저장
2. 변수 i를 만들어 1부터 n까지의 숫자를 1씩 증가시키며 반복
3. [반복 블록] 기존의 s에 i를 더하여 얻은 값을 다시 s에 저장
4. 반복이 끝났을 때 s에 저장된 값이 결괏값

* 알고리즘을 하나의 함수로 만들어 입력은 인자로 전달하고, 출력은 함수의 결괏값(return 값)으로 만들면, 알고리즘이 '입력 -> 알고리즘 -> 출력'을 수행하는 과정이라는 것을 더 직관적으로 이해할 수 있음

```python
# 1부터 n까지 연속한 숫자의 합을 구하는 알고리즘1
# 입력: n
# 출력: 1부터 n까지의 숫자를 더한 값

def sum_n(n):
    s = 0                       # 합을 계산할 변수
    for i in range(1, n+1):     # 1부터 n까지 반복(n+1은 제외)
        s = s+i
    return s

print(sum_n(10))                # 1부터 10까지의 합(입력: 10, 출력: 55)
print(sum_n(100))               # 1부터 100까지의 합(입력: 100, 출력: 5050)

'''
55
5050
'''
```



### (4) 알고리즘 분석

가우스의 발견을 일반화해서 만든 1부터  n까지의 합 공식

n(n+1)/2

이 공식을 이용해 '1부터 n까지 연속한 숫자의 합 구하기' 문제를 푸는 파이썬 프로그램

```python
# 1부터 n까지 연속한 숫자의 합을 구하는 알고리즘 2
# 입력: n
# 출력: 1부터 n까지의 숫자를 더한 값

def sum_n(n):
    return n*(n+1)//2  # 슬래시 두 개(//)는 정수 나눗셈을 의미


print(sum_n(10))    # 1부터 10까지의 합(입력: 10, 출력: 55)
print(sum_n(100))   # 1부터 100까지의 합(입력: 100, 출력: 5050)


'''
55
5050
'''
```

'알고리즘 분석' <- 주어진 문제를 푸는 여러 가지 방법 중 어떤 방법이 더 좋은 것인지 판단할 때 필요



### (5) 입력 크기와 계산 횟수

알고리즘에는 입력이 필요한데 입력 크기가 알고리즘 수행 성능에 영향을 미칠 때가 많다.

* 첫 번째 알고리즘 : 덧셈 n번
* 두 번째 알고리즘 : 덧셈, 곱셈, 나눗셈 각 한 번(총 세 번)

입력 크기 n이 작을 때는 큰 차이가 없지만 알고리즘 분석에서는 매우 큰 n에 대해서 따져보아야 한다.



### (6) 대문자 O 표기법: 계산 복잡도 표현

'계산 복잡도(complexity)' : 어떤 알고리즘이 문제를 풀기 위해 해야 하는 계산이 얼마나 복잡한지 나타낸 정도

'빅 오' 표기법 : 대문자 O 표기법은 알고리즘에서 필요한 계산 횟수를 정확한 숫자로 표현하지 않고 입력 크기 n과의 관계로 표현. 알고리즘의 대략적인 성능을 표시하는 방법. 

* 필요한 계산 횟수가 입력 크기에 '비례' : O(n)
* 입력 크기 n과 필요한 계산의 횟수가 무관 : O(1)

첫 번째 알고리즘은 입력 크기 n에 대해 사칙 연산(덧셈)을 n번 해야 하므로, 이 알고리즘의 계산 복잡도는 O(n). 필요한 계산 횟수가 입력 크기에 '정비례'할 때 O(n)

두 번째 알고리즘은 입력 크기 n과 무관하게 사칙연산을 세 번 하므로 O(1)

```
알고리즘의 계산 복잡도는 시간 복잡도(time complexity)와 공간 복잡도(space complexity)로 나눌 수 있다.
시간 복잡도 : 어떤 알고리즘을 수행하는 데 얼마나 오랜 시간이 걸리는지 분석
공간 복잡도 : 어떤 알고리즘을 수행하는 데 얼마나 많은 공간(메모리/기억 장소)이 필요한지 분석

앞서 사칙연산 횟수로 계산 복잡도를 생각한 것은 '시간 복잡도'에 해당
어떤 알고리즘을 수행하는 데 필요한 사칙연산의 횟수가 많아지면 결국 알고리즘 전체를 수행하는 시간이 늘어나므로.
책에 나오는 '계산 복잡도'는 특별한 말 없으면 '시간 복잡도'
```



## [2] 최댓값 찾기

### (1) 리스트

주어진 숫자 n개 중 가장 큰 숫자 찾는 알고리즘

* 필요한 파이썬 리스트 기능

```
리스트(list) : 정보 여러 개를 하나로 묶어 저장하고 관리. 대괄호[] 안에 정보 여러개를 ,로 구분
숫자 여러개는 파이썬의 리스트 기능을 이용하면 쉽게 관리 가능

* 자료 위치를 1이 아닌 0부터 센다
* 위치 번호 -1은 리스트의 끝에서 첫 번째 값, 즉 마지막 값
ex) 자료 n개 든 리스트 b에서 마지막 값은 b[n-1] 또는 b[-1]
```

* len() 함수 : 리스트 안에 들어 있는 자료 개수(리스트의 길이) len(a), len( [1, 2, 3] )

* append(x) : 자료 x를 리스트의 맨 뒤에 추가 a.append(4)

* insert(i, x) : 리스트의 i번 위치에 x를 추가 a.insert(0, 5)  # 0번 위치(맨 앞)에 5 추가

* pop(i) : i번 위치에 있는 자료를 리스트에서 빼내면서 그 값을 함수의 결괏값으로 돌려줌. i 지정하지 않으면 맨 마지막 값 print(a.pop())

* clear() : 리스트의 모든 자료 지우기

* x in a : 어떤 자료 x가 리스트 a 안에 있는지 확인(x not in a는 반대 결과) True / False

  

### (2) 최댓값을 찾는 알고리즘

17, 92, 18, 33, 58, 7, 33, 42

1. 첫 번째 숫자 17을 최댓값으로 기억(최댓값: 17)
2. 두 번째 숫자 92를 현재 최댓값 17과 비교. 92는 17보다 크므로 최댓값을 92로 바꿔 기억(최댓값: 92)
3. 세 번째 숫자 18을 현재 최댓값 92와 비교. 18은 92보다 작으므로 지나간다(최댓값: 92)

4~7. 네 번째 숫자부터 일곱 번째 숫자까지 같은 과정 반복

8. 마지막 숫자 42를 현재 최댓값 92와 비교. 42는 92보다 작으므로 지나간다(최댓값: 92)
9. 마지막으로 기억된 92가 주어진 숫자 중 최댓값

```python
# 최댓값 구하기
# 입력: 숫자가 n개 들어 있는 리스트
# 출력: 숫자 n개 중 최댓값

def find_max(a):
    n = len(a)              # 입력 크기 n
    max_v = a[0]            # 리스트의 첫 번째 값을 최댓값으로 기억
    for i in range(1, n):   # 1부터 n-1까지 반복
        if a[i] > max_v:    # 이번 값이 현재까지 기억된 최댓값보다 크면
            max_v = a[i]    # 최댓값을 변경
    return max_v


v = [17, 92, 18, 33, 58, 7, 33, 42]
print(find_max(v))


'''
92
'''
```

