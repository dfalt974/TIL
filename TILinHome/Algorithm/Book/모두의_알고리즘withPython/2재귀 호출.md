# 재귀 호출

함수가 자기 자신을 다시 호출하는 것

## [4] 팩토리얼 구하기

1부터 n까지 연속한 정수의 곱을 구하는 알고리즘. 즉 팩토리얼(factorial) 구하기

### (1) 팩토리얼

팩토리얼 : 숫자 뒤에 ! 붙여 표기. 1부터 n까지 연속한 숫자를 차례로 곱한 값. '계승'

1! = 1

3! = 1 X 2 X 3 = 6

5! = 1 X 2 X 3 X 4 X 5 = 120

n! = 1 X 2 X 3 X ... X (n-1) X n

단, 0!은 1이라고 약속

팩토리얼 구하는 프로그램은 1부터 n까지 숫자 더하기를 조금 고치면 됨

```python
# 연속한 숫자의 곱을 구하는 알고리즘
# 입력: n
# 출력: 1부터 n까지 연속한 숫자를 곱한 값

def fact(n):
    f = 1                       # 곱을 계산할 변수, 초깃값은 1
    for i in range(1, n+1):     # 1부터 n까지 반복(n+1 제외)
        f = f * i               # 곱셈 연산으로 수정
    return f


print(fact(1))                  # 1! = 1
print(fact(5))                  # 5! = 120
print(fact(10))                 # 10! = 3628800


'''
1
120
3628800
'''
```

'재귀 호출' 방식으로 팩토리얼을 구하는 알고리즘



### (3) 재귀 호출: 다시 돌아가 부르기

재귀 호출(recursion)은 어떤 함수 안에서 자기 자신을 부르는 것

```python
def hello():
    print("hello")
    hello()  # hello() 함수 안에서 다시 hello() 호출
    

hello()  # hello() 함수를 호출
```

hello() 함수의 정의를 보면 "hello"라는 문장을 화면에 출력한 다음 자기 자신인 hello()를 다시 호출하는데 이것이 재귀 호출이다.

"hello"를 출력한 후 다시 자기 자신을 호출하므로 또 다시 "hello"를 출력하고, 다시 자기 자신을 호출해서 "hello"를 출력하는 과정을 영원히 반복(-> 함수 호출에 필요한 기억 장소를 다 써 버리고 나면 에러를 내고 정지. 반복 멈추려면 Ctrl + C)

재귀 호출 프로그램이 정상적으로 작동하려면 '종료 조건' 필요

즉, 특정 조건이 되면 더는 자신을 호출하지 않고 멈추도록 설계. 

그렇지 않으면 계속 반복하다가 재귀 에러가 남.(RecursionError 발생)

재귀 호출 함수가 계산 결과를 돌려줄 때는 return 명령을 사용해서 종료 조건의 결괏값부터 돌려준다. 종료 조건의 결괏값은 마지막으로 호출된 함수의 결괏값.



### (4) 재귀 호출 알고리즘

팩토리얼은 1부터 n까지 연속한 숫자의 곱.

팩토리얼은 재귀 호출로 표현하면

1! = 1

2! = 2 X 1 = 2 X 1!

3! = 3 X (2 X 1) = 3 X 2!

4! = 4 X (3 X 2 X 1) = 4 X 3!

...

n! = n X (n-1)!  <- 팩토리얼을 구하려고 다시 팩토리얼을 구함(재귀적 정의)

여기서 1! = 1 그리고 n! = n X (n-1)!이라는 팩토리얼의 성질을 이용해서 팩토리얼을 구하는 프로그램을 만들면,

```python
# 연속한 숫자의 곱을 구하는 알고리즘
# 입력: n
# 출력: 1부터 n까지 연속한 숫자를 곱한 값

def fact(n):
    if n <= 1:
        return 1
    return n * fact(n - 1)

print(fact(1))      # 1! = 1
print(fact(5))      # 5! = 120
print(fact(10))     # 10! = 3628800
```

우선 n이 1 이하인지 비교해서 1 이하(0 포함)는 아주 작아서 더는 계산하지 않아도 되는 '종료 조건'이다.(러시아 인형에서 가장 작은 마지막 인형에 해당)

이때 1을 결괏값으로 돌려준다.(마지막 인형 안에 든 사탕에 해당)

n이 1보다 크면 n! = n X (n-1)! 이므로 n * fact(n-1)을 결괏값으로 돌려준다.

이 과정에서 n!을 구하기 위해 약간 더 작은 값인 (n-1)!을 구하는 fact(n-1)이 재귀 호출된다.(인형 안에 든 조금 더 작은 인형에 해당)

fact(n)을 풀기 위해서 fact(n-1)을 재귀 호출했는데 호출된 fact(n-1)은 어떻게 실행될까?

다시 종료 조건에 해당하는지 확인하고 종료 조건이 아니라면 이번에는 fact(n-2)를 호출한다.

마찬가지로 fact(n-3), fact(n-4), ...  이렇게 반복하다 보면 결국 fact(1)을 만남(영원한 반복X. 답)



ex) fact(4) 호출

1. fact(4)는 4 * fact(3)이므로 fact(3)을 호출
2. fact(3)은 3 * fact(2)이므로 fact(2)를 호출
3. fact(2)는 2 * fact(1)이므로 fact(1)을 호출
4. fact(1)은 종료 조건이므로 fact() 함수를 더 이상 호출하지 않고 1을 돌려줌
5. fact(2)는 fact(1)에서 돌려받은 결괏값 1에 2를 곱해 2를 돌려주고
6. fact(3)은 fact(2)에서 돌려받은 결괏값 2에 3을 곱해 6을 돌려주고
7. fact(4)는 fact(3)에서 돌려받은 결괏값 6에 4를 곱해 24를 돌려줌(최종 결과)

```
fact(4)   
  -> 4 * fact(3)            
           -> 3 * fact(2)
                    -> 2 * fact(1)                              
                             -> 1(n이 1이므로 종료조건)                    
                    -> 2 * 1
           -> 3 * 2 * 1  
  -> 4 * 3 * 2 * 1 = 24(최종 결과)    
  
  4!
  = 4 X 3!
  = 4 X 3 X 2!
  = 4 X 3 X 2 X 1!
  = 4 X 3 X 2 X 1(1은 종료 조건이므로 재귀 호출을 멈춤)
  = 4 X 3 X 2
  = 4 X 6
  = 24
```



### (5) 알고리즘 분석

n!을 구하기 위해 for 반복문을 이용하면 곱셈이 n번 필요하다.

재귀 호출 알고리즘을 이용한 경우, fact(4) 계산 과정을 보면 알 수 있듯 fact(4)를 구하기 위해 fact(1)의 종료 조건으로 돌려받은 1을 2와 곱하여 돌려준다. 그리고 그 값에 다시 3을 곱하여 돌려주고, 다시 그 값에 4를 곱하여 돌려주면 곱셈이 모두 세 번 필요하다. n!을 구하기 위해 곱셈이 모두 n-1번 필요하다. 

둘 다 O(n)

```python
def func(입력 값):
    if 입력 값이 충분히 작으면:  # 종료 조건
        return 결괏값
    ...
    func(더 작은 입력 값)  # 더 작은 값으로 자기 자신을 호출
    ...
    return 결괏값
```

재귀 호출에는 종료 조건이 반드시 필요하다

종료 조건이 없으면 재귀 에러(RecursionError)나 스택 오버플로(Stack Overflow) 등 프로그램 에러가 발생해 비정상적인 동작을 할 수도 있다.

## 

## [5] 최대공약수 구하기

두 자연수 a와 b의 최대공약수를 구하는 알고리즘

최대공약수(Greatest Common Divisor, GCD)는 두 개 이상의 정수의 공통 약수 중 가장 큰 값.

두 자연수의 최대공약수를 찾으려면

1. 두 수의 약수 중
2. 공통된 것을 찾아
3. 그 값 중 최댓값 찾기



### (1) 최대공약수 알고리즘

1. 두 수 중 더 작은 값을 i에 저장
2. i가 두 수의 공통된 약수인지 확인
3. 공통된 약수이면 이 값을 결괏값으로 돌려주고 종료
4. 공통된 약수가 아니면 i를 1만큼 감소시키고 2번으로 돌아가 반복(1은 모든 정수의 약수이므로 i가 1이 되면 1을 결괏값으로 돌려주고 종료)

ex) 4와 6의 최대공약수 찾기

1. i에 4를 저장(4와 6 중 작은 값인 4가 최대공약수 후보 중 가장 큰 값)
2. 4는 i로 나누어떨어지지만, 6은 나누어떨어지지 않는다.
3. i를 1만큼 감소시켜 3으로 만든다
4. 4는 i로 나누어떨어지지 않는다
5. i를 1만큼 감소시켜 2로 만든다
6. 4도 i로 나누어떨어지고 6도 i로 나누어떨어지므로 i값 2가 최대공약수

```python
# 최대공약수 구하기
# 입력: a, b
# 출력: a와 b의 최대공약수

def gcd(a, b):
    i = min(a, b)  # 두 수 중에서 최솟값을 구하는 파이썬 함수
    while True:
        if a % i == 0 and b % i == 0:
            return i
        i = i - 1  # i를 1만큼 감소시킴
        

print(gcd(1, 5))    # 1
print(gcd(3, 6))    # 3
print(gcd(60, 24))  # 12
print(gcd(81, 27))  # 27
```



### (2) 유클리드 알고리즘

수학자 유클리드(Euclid)는 최대공약수에 다음과 같은 성질이 있다는 것을 발견

- a와 b의 최대공약수는 'b'와 'a를 b로 나눈 나머지'의 최대공약수가 같다.

  즉, gcd(a, b) = gcd(b, a%b)

- 어떤 수와 0의 최대공약수는 자기 자신. 즉, gcd(n, 0) = n

예를 들어,

gcd(60, 24) = gcd(24, 60%24) = gcd(24, 12) = gcd(12, 24%12) = gcd(12, 0) = 12

어떤 두 수의 최대공약수를 구하기 위해 다시 다른 두 수의 최대공약수를 구하고 있다.('재귀 호출')

a와 b의 최대공약수를 구하기 위해서 (a, b)보다 좀 더 작은 숫자인 (b, a%b)의 최대공약수를 구하는 과정을 이용하는 전형적인 재귀 호출 문제.(좀 더 작은 값으로 자기 자신을 호출)

재귀 호출이 무한히 반복되지 않도록 하는 데 필요한 종료 조건은 '어떤 수와 0의 최대공약수는 자기 자신'이라는 성질. 즉, b가 0이면 재귀 호출을 멈추고 결과를 돌려줌



## [6] 하노이의 탑 옮기기

원반이 n개인 하노이의 탑을 옮기기 위한 원반 이동 순서를 출력하는 알고리즘

### (1) 하노이의 탑

하노이의 탑(Tower of Hanoi)은 간단한 원반(disk) 옮기기 퍼즐.

하노이의 탑에는 크기가 다른 원반이 n개 있고 원반을 끼울 수 있는 기둥이 세 개 있다.

어떻게 하면 원반 n개를 모두 가장 왼쪽 기둥(출발점, 즉 1번 기둥)에서 오른쪽 기둥(도착점, 즉 3번 기둥)으로 옮길 수 있을까?

단, 원반은 한 번에 한개씩만 옮길 수 있고, 각 기둥 맨 위의 원반은 다른 기둥의 맨 위로만 움직여야함. 옮기는 과정에서 큰 원반을 작은 원반 위에 올려서는 안됨.

이 규칙을 지키면서 원반을 옮기려면 중간에 여분으로 주어진 보조 기둥(2번 기둥)을 잘 활용해야 함.

- 크기가 다른 원반 n개를 출발점 기둥에서 도착점 기둥으로 전부 옮겨야 한다.
- 원반은 한 번에 한 개씩만 옮길 수 있다.
- 원반을 옮길 때는 한 기둥에 맨 위 원반을 뽑아, 다른 기둥의 맨 위로만 옮길 수 있다.
- 원반을 옮기는 과정에서 큰 원반을 작은 원반 위로 올릴 수 없다.

### (2) 하노이의 탑 풀이