## 그래프

- 인터넷, 도로, 운송, 전력, 상하수도망, 신경망, 화학성분 결합, 단백질 네트워크, 금융 네트워크, 소셜 네트워크 분석(Social Network Analysis) 등의 광범위한 분야에서 활용되는 자료구조

* 그래프의 기본 연산
  - 깊이우선탐색(Depth First Search, DFS)
  - 너비우선탐색(Breath First Search, BFS)
* 연결성분(Connected Component) 찾는 방법
* 위상정렬(Topological Sort)
* 이중연결성분, 강연결성분
* 가중치 그래프에서 최소신장트리(Minimum Spanning Tree)를 찾기 위한 알고리즘
* 최단경로 찾는 알고리즘



### 그래프

#### 그래프 용어

- 그래프 : 정점(Vertex)와 간선(Edge)의 집합으로 하나의 간선은 두 개의 정점을 연결

* G=(V, E) : V는 정점의 집합, E는 간선의 집합
* 방향 그래프(Directed Graph) : 간선에 방향이 있는 그래프
* 무방향 그래프(Undirected Graph) : 간선에 방향이 없는 그래프

** 오일러(Leonhard Euler, 1707-1783) : 스위스의 수학자, 물리학자, 천문학자, 논리학자, 공학자로서 그래프의 아버지로도 불림



정점 a와 b를 연결하는 간선 (a, b)

정점 a에서 b로 간선의 방향이 있는 경우 <a, b>

정점 a에 인접한 정점의 수 : a의 차수(Degree)

방향 그래프에서는 차수를 진입 차수(In-degree)와 진출 차수(Out-degree)로 구분



경로(Path)는 시작 정점 u부터 도착점 v까지의 정점들을 나열하여 표현

단순 경로(Simple Path) : 경로 상의 정점들이 모두 다른 경로 

싸이클(Cycle) : 시작 정점과 도착점이 동일한 단순 경로



그래프에서 정점들이 서로 연결되어 있는 부분 : 연결성분(Connected Component)

가중치(Weighted) 그래프 : 간선에 가중치가 부여된 그래프. 가중치는 실제 두 정점 사이의 거리가 될 수도 있고, 두 정점을 연결하는 간선을 지나는 데에 소요되는 시간이 될 수도 있음. 가중치가 음수인 경우도 존재.

부분그래프(Subgraph) : 주어진 그래프의 정점과 간선의 일부분(부분 집합)으로 이루어진 그래프. 원래의 그래프에 없는 정점이나 간선을 포함하지 않음. 사이클이 없는 그래프를 트리(Tree)라 하고, 주어진 그래프가 하나의 연결성분으로 구성되어 있을 때, 그래프의 모든 정점들을 사이클 없이 연결하는 부분그래프를 신장트리(Spanning Tree)라고 함



####  그래프 자료구조

그래프를 자료구조로서 저장하기 위한 방법 : 인접행렬(Adjacency Matrix), 인접리스트(Adjacency List)가 주로 사용

N개의 정점을 가진 그래프의 인접행렬은 2차원 N x N 리스트에 저장 가능

인접행렬을 저장할 리스트가 a라면, 정점들을 0, 1, 2, ... , N-1로 하여,

정점 i와 j사이에 간선이 없으면 $a[i][j] = 0$으로, 간선이 있으면 $a[i][j] = 1$로 표현

가중치 그래프는 1 대신 가중치를 저장

인접리스트는 각 정점마다 1개의 단순연결리스트를 이용하여 인접한 각 정점을 노드에 저장

파이썬에서는 리스트를 그래프로

```python
adj = [[1, 2], [0, 2, 3], [0, 1, 3], [1, 2]]
```

이러한 구현은 사실상 인접행렬과 인접리스트를 동시에 반영한 것이라고 할 수 있는데

간선 (1, 3)은 $adj[1][2]$로서 2차원 행렬과 같이 접근할 수 있고, adj[1]은 정점 1에 인접한 정점의 리스트로서 마치 단순연결리스트와 같이 순차적으로 각 인접한 정점을 접근할 수도 있기 때문



이외에도 입력 그래프를 문제에 따라 여러 방식으로 표현 가능

실세계의 그래프는 대부분 정점의 차수가 작은 희소 그래프(Sparse Graph)

즉, 희소 그래프의 간선 수는 최대 간선 수인 $N(N-1)/2$ 보다 훨씬 작은데, 이 경우 희소 그래프를 효율적으로 저장하는 자료구조는 인접리스트이다.

간선의 수가 최대 간선 수에 근접한 그래프는 조밀 그래프(Dense Graph)



### 그래프 탐색

그래프에서는 두 가지 방식으로 모든 정점을 방문할 수 있다.

* 깊이우선탐색(DFS; Depth First Search)
* 너비우선탐색(BFS; Breadth First Search)

#### 깊이 우선 탐색

그래프에서의 DFS는 임의의 정점에서 시작하여 이웃하는 하나의 정점을 방문하고, 방금 방문한 정점의 이웃 정점을 방문하여, 이웃하는 정점들을 모두 방문한 경우에는 이전 정점으로 되돌아 가서 탐색을 수행하는 방식으로 진행

* DFS는 실타래를 가지고 미로에서 출구를 찾는 것과 유사. 새로운 곳으로 갈 때는 실타래를 풀면서 진행하고, 길이 막혀 진행할 수 없을 때에는 실타래를 되감으며 왔던 길로 되돌아 가서 다른 경로를 탐색하여 출구를 찾는다

```python
# dfs.py

# 그래프의 인접리스트
adj_list = [[2, 1], [3, 0], [3, 0], [9, 8, 2, 1],
           [5], [7, 6, 4], [7, 5], [6, 5], [3], [3]]
N = len(adj_list)

# 정점 방문 여부 확인
visited = [False] * N

def dfs(v):
    # 정점 v 방문
    visited[v] = True
    print(v, ' ', end='')
    
    for w in adj_list[v]:
        if not visited[w]:
            # 정점 v에 인접한 정점으로 dfs() 재귀호출
            dfs(w)
     
print('DFS 방문 순서:')
for i in range(N):
    if not visited[i]:
        # dfs() 호출
        dfs(i)
```

입력 그래프가 여러 개의 연결성분으로 구성된 경우, 정점 0으로부터 방문을 시작하여 DFS를 수행하면 정점 0이 속한 연결성분의 정점들만 방문하여 첫 연결성분을 찾는다.

for-루프를 통해 아직 방문 안된 정점을 시작으로 다른 연결성분을 찾는다.

DFS 방문 순서대로 정점 0부터 위에서 아래 방향으로 정점들을 그려 트리를 만들 때, 그래프를 탐색하며 처음 방문할 때 사용된 간선을 실선으로, 탐색 중 이미 방문된 정점에 도달한 경우 점선(뒷간선. Back Edge)로 나타낼 때, 입력 그래프가 하나의 연결성분으로 되어 DFS를 수행하며 실선으로 만들어지는 트리를 깊이우선 신장트리(Depth First Spanning Tree)라고 함

DFS의 수행시간은 탐색이 각 정점을 한 번씩 방문하며, 각 간선을 1번씩만 사용하여 탐색하기 때문에 O(N+M)이다. N은 그래프의 정점의 수, M은 간선의 수 